// Generated by Haxe 4.2.0
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
}
EReg.__name__ = "EReg";
Object.assign(EReg.prototype, {
	__class__: EReg
	,r: null
});
class HxOverrides {
	static dateStr(date) {
		let m = date.getMonth() + 1;
		let d = date.getDate();
		let h = date.getHours();
		let mi = date.getMinutes();
		let s = date.getSeconds();
		return date.getFullYear() + "-" + (m < 10 ? "0" + m : "" + m) + "-" + (d < 10 ? "0" + d : "" + d) + " " + (h < 10 ? "0" + h : "" + h) + ":" + (mi < 10 ? "0" + mi : "" + mi) + ":" + (s < 10 ? "0" + s : "" + s);
	}
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = "HxOverrides";
class Lambda {
	static array(it) {
		let a = [];
		let i = $getIterator(it);
		while(i.hasNext()) {
			let i1 = i.next();
			a.push(i1);
		}
		return a;
	}
	static has(it,elt) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(x1 == elt) {
				return true;
			}
		}
		return false;
	}
	static exists(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(f(x1)) {
				return true;
			}
		}
		return false;
	}
	static iter(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			f(x1);
		}
	}
}
Lambda.__name__ = "Lambda";
Math.__name__ = "Math";
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return null;
		}
	}
	static getProperty(o,field) {
		let tmp;
		if(o == null) {
			return null;
		} else {
			let tmp1;
			if(o.__properties__) {
				tmp = o.__properties__["get_" + field];
				tmp1 = tmp;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				return o[tmp]();
			} else {
				return o[field];
			}
		}
	}
	static fields(o) {
		let a = [];
		if(o != null) {
			let hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static isFunction(f) {
		if(typeof(f) == "function") {
			return !(f.__name__ || f.__ename__);
		} else {
			return false;
		}
	}
	static compare(a,b) {
		if(a == b) {
			return 0;
		} else if(a > b) {
			return 1;
		} else {
			return -1;
		}
	}
	static compareMethods(f1,f2) {
		if(f1 == f2) {
			return true;
		}
		if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
			return false;
		}
		if(f1.scope == f2.scope && f1.method == f2.method) {
			return f1.method != null;
		} else {
			return false;
		}
	}
	static isObject(v) {
		if(v == null) {
			return false;
		}
		let t = typeof(v);
		if(!(t == "string" || t == "object" && v.__enum__ == null)) {
			if(t == "function") {
				return (v.__name__ || v.__ename__) != null;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
}
Reflect.__name__ = "Reflect";
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		if(x != null) {
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				let c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					let nc = x.charCodeAt(i + 1);
					let v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
}
Std.__name__ = "Std";
class StringBuf {
	constructor() {
		this.b = "";
	}
}
StringBuf.__name__ = "StringBuf";
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
	,b: null
});
class StringTools {
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static lpad(s,c,l) {
		if(c.length <= 0) {
			return s;
		}
		let buf_b = "";
		l -= s.length;
		while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
		buf_b += s == null ? "null" : "" + s;
		return buf_b;
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = "StringTools";
class haxe_io_Input {
	readByte() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Input.hx", lineNumber : 53, className : "haxe.io.Input", methodName : "readByte"});
	}
	readBytes(s,pos,len) {
		let k = len;
		let b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return len - k;
	}
	readFullBytes(s,pos,len) {
		while(len > 0) {
			let k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	readLine() {
		let buf = new haxe_io_BytesBuffer();
		let last;
		let s;
		try {
			while(true) {
				last = this.readByte();
				if(!(last != 10)) {
					break;
				}
				buf.addByte(last);
			}
			s = buf.getBytes().toString();
			if(HxOverrides.cca(s,s.length - 1) == 13) {
				s = HxOverrides.substr(s,0,-1);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof haxe_io_Eof)) {
				let e = _g1;
				s = buf.getBytes().toString();
				if(s.length == 0) {
					throw haxe_Exception.thrown(e);
				}
			} else {
				throw _g;
			}
		}
		return s;
	}
	readString(len,encoding) {
		let b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
}
haxe_io_Input.__name__ = "haxe.io.Input";
Object.assign(haxe_io_Input.prototype, {
	__class__: haxe_io_Input
});
var ValueType = $hxEnums["ValueType"] = { __ename__:"ValueType",__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
class Type {
	static getEnum(o) {
		if(o == null) {
			return null;
		}
		return $hxEnums[o.__enum__];
	}
	static getInstanceFields(c) {
		let result = [];
		while(c != null) {
			let _g = 0;
			let _g1 = Object.getOwnPropertyNames(c.prototype);
			while(_g < _g1.length) {
				let name = _g1[_g];
				++_g;
				switch(name) {
				case "__class__":case "__properties__":case "constructor":
					break;
				default:
					if(result.indexOf(name) == -1) {
						result.push(name);
					}
				}
			}
			c = c.__super__;
		}
		return result;
	}
	static typeof(v) {
		switch(typeof(v)) {
		case "boolean":
			return ValueType.TBool;
		case "function":
			if(v.__name__ || v.__ename__) {
				return ValueType.TObject;
			}
			return ValueType.TFunction;
		case "number":
			if(Math.ceil(v) == v % 2147483648.0) {
				return ValueType.TInt;
			}
			return ValueType.TFloat;
		case "object":
			if(v == null) {
				return ValueType.TNull;
			}
			let e = v.__enum__;
			if(e != null) {
				return ValueType.TEnum($hxEnums[e]);
			}
			let c = js_Boot.getClass(v);
			if(c != null) {
				return ValueType.TClass(c);
			}
			return ValueType.TObject;
		case "string":
			return ValueType.TClass(String);
		case "undefined":
			return ValueType.TNull;
		default:
			return ValueType.TUnknown;
		}
	}
	static enumParameters(e) {
		let enm = $hxEnums[e.__enum__];
		let params = enm.__constructs__[e._hx_index].__params__;
		if(params != null) {
			let _g = [];
			let _g1 = 0;
			while(_g1 < params.length) {
				let p = params[_g1];
				++_g1;
				_g.push(e[p]);
			}
			return _g;
		} else {
			return [];
		}
	}
}
Type.__name__ = "Type";
class haxe_io_Path {
	constructor(path) {
		switch(path) {
		case ".":case "..":
			this.dir = path;
			this.file = "";
			return;
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			this.dir = HxOverrides.substr(path,0,c2);
			path = HxOverrides.substr(path,c2 + 1,null);
			this.backslash = true;
		} else if(c2 < c1) {
			this.dir = HxOverrides.substr(path,0,c1);
			path = HxOverrides.substr(path,c1 + 1,null);
		} else {
			this.dir = null;
		}
		let cp = path.lastIndexOf(".");
		if(cp != -1) {
			this.ext = HxOverrides.substr(path,cp + 1,null);
			this.file = HxOverrides.substr(path,0,cp);
		} else {
			this.ext = null;
			this.file = path;
		}
	}
	static directory(path) {
		let s = new haxe_io_Path(path);
		if(s.dir == null) {
			return "";
		}
		return s.dir;
	}
	static join(paths) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < paths.length) {
			let v = paths[_g1];
			++_g1;
			if(v != null && v != "") {
				_g.push(v);
			}
		}
		if(_g.length == 0) {
			return "";
		}
		let path = _g[0];
		let _g2 = 1;
		let _g3 = _g.length;
		while(_g2 < _g3) {
			let i = _g2++;
			path = haxe_io_Path.addTrailingSlash(path);
			path += _g[i];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		let slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		let target = [];
		let _g = 0;
		let _g1 = path.split(slash);
		while(_g < _g1.length) {
			let token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		let tmp = target.join(slash);
		let acc_b = "";
		let colon = false;
		let slashes = false;
		let _g2_offset = 0;
		let _g2_s = tmp;
		while(_g2_offset < _g2_s.length) {
			let s = _g2_s;
			let index = _g2_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g2_offset;
			}
			let c2 = c1;
			switch(c2) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					let i = c2;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				let i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
	static isAbsolute(path) {
		if(path.startsWith("/")) {
			return true;
		}
		if(path.charAt(1) == ":") {
			return true;
		}
		if(path.startsWith("\\\\")) {
			return true;
		}
		return false;
	}
}
haxe_io_Path.__name__ = "haxe.io.Path";
Object.assign(haxe_io_Path.prototype, {
	__class__: haxe_io_Path
	,dir: null
	,file: null
	,ext: null
	,backslash: null
});
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		while(true) {
			if(cc == null) {
				return false;
			}
			if(cc == cl) {
				return true;
			}
			let intf = cc.__interfaces__;
			if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
				let _g = 0;
				let _g1 = intf.length;
				while(_g < _g1) {
					let i = _g++;
					let i1 = intf[i];
					if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
						return true;
					}
				}
			}
			cc = cc.__super__;
		}
	}
	static __instanceof(o,cl) {
		if(cl == null) {
			return false;
		}
		switch(cl) {
		case Array:
			return ((o) instanceof Array);
		case Bool:
			return typeof(o) == "boolean";
		case Dynamic:
			return o != null;
		case Float:
			return typeof(o) == "number";
		case Int:
			if(typeof(o) == "number") {
				return ((o | 0) === o);
			} else {
				return false;
			}
			break;
		case String:
			return typeof(o) == "string";
		default:
			if(o != null) {
				if(typeof(cl) == "function") {
					if(js_Boot.__downcastCheck(o,cl)) {
						return true;
					}
				} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
					if(((o) instanceof cl)) {
						return true;
					}
				}
			} else {
				return false;
			}
			if(cl == Class ? o.__name__ != null : false) {
				return true;
			}
			if(cl == Enum ? o.__ename__ != null : false) {
				return true;
			}
			return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
		}
	}
	static __downcastCheck(o,cl) {
		if(!((o) instanceof cl)) {
			if(cl.__isInterface__) {
				return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static __implements(o,iface) {
		return js_Boot.__interfLoop(js_Boot.getClass(o),iface);
	}
	static __cast(o,t) {
		if(o == null || js_Boot.__instanceof(o,t)) {
			return o;
		} else {
			throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __isNativeObj(o) {
		return js_Boot.__nativeClassName(o) != null;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js_Boot.__name__ = "js.Boot";
class gmdebug_Cross {
	static readHeader(x) {
		let content_length = x.readLine();
		let skip = 0;
		let _g = 0;
		let _g1 = content_length.length;
		while(_g < _g1) {
			let i = _g++;
			if(HxOverrides.cca(content_length,i) == 4) {
				++skip;
			} else {
				break;
			}
		}
		if(skip > 0) {
			content_length = HxOverrides.substr(content_length,skip,null);
		}
		let content_length1 = Std.parseInt(HxOverrides.substr(content_length,15,null));
		x.readLine();
		return content_length1;
	}
}
gmdebug_Cross.__name__ = "gmdebug.Cross";
var gmdebug_CommMethod = $hxEnums["gmdebug.CommMethod"] = { __ename__:"gmdebug.CommMethod",__constructs__:null
	,Pipe: {_hx_name:"Pipe",_hx_index:0,__enum__:"gmdebug.CommMethod",toString:$estr}
	,Socket: {_hx_name:"Socket",_hx_index:1,__enum__:"gmdebug.CommMethod",toString:$estr}
};
gmdebug_CommMethod.__constructs__ = [gmdebug_CommMethod.Pipe,gmdebug_CommMethod.Socket];
class gmdebug_FrameID {
	static getValue(this1) {
		let clientID = this1 >>> 27;
		let actualFrame = this1 & 134217727;
		return { clientID : clientID, actualFrame : actualFrame};
	}
}
var gmdebug_VariableReferenceVal = $hxEnums["gmdebug.VariableReferenceVal"] = { __ename__:"gmdebug.VariableReferenceVal",__constructs__:null
	,Child: ($_=function(clientID,ref) { return {_hx_index:0,clientID:clientID,ref:ref,__enum__:"gmdebug.VariableReferenceVal",toString:$estr}; },$_._hx_name="Child",$_.__params__ = ["clientID","ref"],$_)
	,FrameLocal: ($_=function(clientID,frameID,ref) { return {_hx_index:1,clientID:clientID,frameID:frameID,ref:ref,__enum__:"gmdebug.VariableReferenceVal",toString:$estr}; },$_._hx_name="FrameLocal",$_.__params__ = ["clientID","frameID","ref"],$_)
	,Global: ($_=function(clientID,ref) { return {_hx_index:2,clientID:clientID,ref:ref,__enum__:"gmdebug.VariableReferenceVal",toString:$estr}; },$_._hx_name="Global",$_.__params__ = ["clientID","ref"],$_)
};
gmdebug_VariableReferenceVal.__constructs__ = [gmdebug_VariableReferenceVal.Child,gmdebug_VariableReferenceVal.FrameLocal,gmdebug_VariableReferenceVal.Global];
class gmdebug_VariableReference {
	static getValue(this1) {
		let clientID = this1 >>> 25 & 15;
		let ref = this1 >>> 29 & 3;
		switch(ref) {
		case 0:
			return gmdebug_VariableReferenceVal.Child(clientID,this1 & 16777215);
		case 1:
			return gmdebug_VariableReferenceVal.FrameLocal(clientID,this1 >>> 8 & 131071,this1 & 255);
		case 2:
			return gmdebug_VariableReferenceVal.Global(clientID,this1 & 16777215);
		}
	}
	static encode(x) {
		let val = x._hx_index << 29;
		switch(x._hx_index) {
		case 0:
			let _g = x.ref;
			let ref = _g;
			val |= x.clientID << 25;
			ref = _g + 1;
			return val | ref - 1;
		case 1:
			let _g1 = x.ref;
			let ref1 = _g1;
			val |= x.clientID << 25;
			val |= x.frameID << 8;
			ref1 = _g1 + 1;
			return val | ref1 - 1;
		case 2:
			let _g2 = x.ref;
			let ref2 = _g2;
			val |= x.clientID << 25;
			ref2 = _g2 + 1;
			return val | ref2 - 1;
		}
	}
}
class gmdebug_composer_ComposeTools {
	static compose(req,str,body) {
		let response = new gmdebug_composer_ComposedResponse(req,body);
		response.success = true;
		return response;
	}
	static composeFail(req,rawerror,error) {
		let response = new gmdebug_composer_ComposedResponse(req,error);
		response.message = rawerror;
		response.success = false;
		return response;
	}
}
gmdebug_composer_ComposeTools.__name__ = "gmdebug.composer.ComposeTools";
class gmdebug_composer_ComposedProtocolMessage {
	constructor(_type) {
		if(gmdebug_composer_ComposedProtocolMessage._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(_type);
	}
	_hx_constructor(_type) {
		this.seq = 0;
		this.type = _type;
	}
}
gmdebug_composer_ComposedProtocolMessage.__name__ = "gmdebug.composer.ComposedProtocolMessage";
Object.assign(gmdebug_composer_ComposedProtocolMessage.prototype, {
	__class__: gmdebug_composer_ComposedProtocolMessage
	,seq: null
	,type: null
});
class gmdebug_composer_ComposedEvent extends gmdebug_composer_ComposedProtocolMessage {
	constructor(str,body) {
		super("event");
		this.event = str;
		this.body = body;
	}
}
gmdebug_composer_ComposedEvent.__name__ = "gmdebug.composer.ComposedEvent";
gmdebug_composer_ComposedEvent.__super__ = gmdebug_composer_ComposedProtocolMessage;
Object.assign(gmdebug_composer_ComposedEvent.prototype, {
	__class__: gmdebug_composer_ComposedEvent
	,event: null
	,body: null
});
class gmdebug_composer_ComposedGmDebugMessage extends gmdebug_composer_ComposedProtocolMessage {
	constructor(msg,body) {
		super("gmdebug");
		this.msg = msg;
		this.body = body;
	}
}
gmdebug_composer_ComposedGmDebugMessage.__name__ = "gmdebug.composer.ComposedGmDebugMessage";
gmdebug_composer_ComposedGmDebugMessage.__super__ = gmdebug_composer_ComposedProtocolMessage;
Object.assign(gmdebug_composer_ComposedGmDebugMessage.prototype, {
	__class__: gmdebug_composer_ComposedGmDebugMessage
	,msg: null
	,body: null
});
class gmdebug_composer_ComposedRequest extends gmdebug_composer_ComposedProtocolMessage {
	constructor(str,args) {
		super("request");
		this.command = str;
		this.arguments = args;
	}
}
gmdebug_composer_ComposedRequest.__name__ = "gmdebug.composer.ComposedRequest";
gmdebug_composer_ComposedRequest.__super__ = gmdebug_composer_ComposedProtocolMessage;
Object.assign(gmdebug_composer_ComposedRequest.prototype, {
	__class__: gmdebug_composer_ComposedRequest
	,command: null
	,'arguments': null
});
class gmdebug_composer_ComposedResponse extends gmdebug_composer_ComposedProtocolMessage {
	constructor(req,body) {
		gmdebug_composer_ComposedProtocolMessage._hx_skip_constructor = true;
		super();
		gmdebug_composer_ComposedProtocolMessage._hx_skip_constructor = false;
		this._hx_constructor(req,body);
	}
	_hx_constructor(req,body) {
		this.success = true;
		super._hx_constructor("response");
		this.request_seq = req.seq;
		this.command = req.command;
		this.body = body;
	}
}
gmdebug_composer_ComposedResponse.__name__ = "gmdebug.composer.ComposedResponse";
gmdebug_composer_ComposedResponse.__super__ = gmdebug_composer_ComposedProtocolMessage;
Object.assign(gmdebug_composer_ComposedResponse.prototype, {
	__class__: gmdebug_composer_ComposedResponse
	,request_seq: null
	,success: null
	,command: null
	,message: null
	,body: null
});
class gmdebug_dap_BaseConnected {
	constructor(fs,clID) {
		this.socket = fs;
		this.clID = clID;
	}
	sendRaw(x) {
		this.socket.write(x);
	}
	disconnect() {
		this.socket.end();
	}
}
gmdebug_dap_BaseConnected.__name__ = "gmdebug.dap.BaseConnected";
Object.assign(gmdebug_dap_BaseConnected.prototype, {
	__class__: gmdebug_dap_BaseConnected
	,socket: null
	,clID: null
});
class gmdebug_dap_BytesProcessor {
	constructor() {
		this.lastGoodPos = 0;
		this.prevBytes = [];
		this.prevClientResults = [];
		this.fillRequested = false;
	}
	process(jsBuf,clientNo) {
		this.fillRequested = false;
		let bytes = js_node_buffer__$Buffer_Helper.bytesOfBuffer(jsBuf);
		bytes = this.conjoinHandle(bytes,clientNo);
		return this.processBytes(bytes,clientNo);
	}
	processBytes(rawBytes,clientNo) {
		let input = new haxe_io_BytesInput(rawBytes);
		try {
			return this.addMessages(input,clientNo);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g);
			let _g2 = _g1.unwrap();
			if(((_g2) instanceof haxe_io_Eof)) {
				this.lastGoodPos = input.pos;
				this.prevClientResults[clientNo] = null;
				this.prevBytes[clientNo] = rawBytes.sub(this.lastGoodPos,rawBytes.length - this.lastGoodPos);
				return [];
			} else if(typeof(_g2) == "string") {
				let e = _g2;
				this.lastGoodPos = input.pos;
				this.prevClientResults[clientNo] = null;
				this.prevBytes[clientNo] = rawBytes.sub(this.lastGoodPos,rawBytes.length - this.lastGoodPos);
				haxe_Log.trace(e,{ fileName : "src/gmdebug/dap/BytesProcessor.hx", lineNumber : 39, className : "gmdebug.dap.BytesProcessor", methodName : "processBytes"});
				return [];
			} else {
				throw haxe_Exception.thrown(_g1);
			}
		}
	}
	addMessages(inp,clientNo) {
		let messages = [];
		while(inp.pos != inp.totlen && this.skipAcks(inp)) {
			let prevResult = this.prevClientResults[clientNo];
			let result;
			if(prevResult == null) {
				result = this.recvMessage(inp);
			} else {
				switch(prevResult._hx_index) {
				case 0:
					result = this.recvMessage(inp);
					break;
				case 1:
					result = this.recvMessage(inp,prevResult.remaining);
					break;
				}
			}
			let tmp = this.prevClientResults;
			let tmp1;
			if(prevResult == null) {
				switch(result._hx_index) {
				case 0:
					messages.push(new haxe_format_JsonParser(result.x).doParse());
					tmp1 = result;
					break;
				case 1:
					tmp1 = result;
					break;
				}
			} else if(prevResult._hx_index == 1) {
				let _g = prevResult.x;
				switch(result._hx_index) {
				case 0:
					messages.push(new haxe_format_JsonParser(_g + result.x).doParse());
					tmp1 = result;
					break;
				case 1:
					tmp1 = gmdebug_dap_RecvMessageResponse.Unfinished(_g + result.x,result.remaining);
					break;
				}
			} else {
				switch(result._hx_index) {
				case 0:
					messages.push(new haxe_format_JsonParser(result.x).doParse());
					tmp1 = result;
					break;
				case 1:
					tmp1 = result;
					break;
				}
			}
			tmp[clientNo] = tmp1;
		}
		return messages;
	}
	conjoinHandle(curBytes,clientNo) {
		let oldByte = this.prevBytes[clientNo];
		if(oldByte != null) {
			let conjoinedBytes = new haxe_io_Bytes(new ArrayBuffer(oldByte.length + curBytes.length));
			conjoinedBytes.blit(0,oldByte,0,oldByte.length);
			conjoinedBytes.blit(oldByte.length,curBytes,0,curBytes.length);
			this.prevBytes[clientNo] = null;
			return conjoinedBytes;
		} else {
			return curBytes;
		}
	}
	recvMessage(input,remaining) {
		if(remaining == null) {
			remaining = gmdebug_Cross.readHeader(input);
		}
		let bufRemaining = input.totlen - input.pos;
		if(remaining > bufRemaining) {
			let str = input.readString(bufRemaining,haxe_io_Encoding.UTF8);
			remaining -= bufRemaining;
			return gmdebug_dap_RecvMessageResponse.Unfinished(str,remaining);
		} else {
			let str = input.readString(remaining,haxe_io_Encoding.UTF8);
			return gmdebug_dap_RecvMessageResponse.Completed(str);
		}
	}
	skipAcks(inp) {
		let _g = inp.pos;
		let _g1 = inp.totlen;
		while(_g < _g1) {
			++_g;
			let byt = inp.readByte();
			if(byt != 4) {
				inp.set_position(inp.pos - 1);
				return true;
			} else {
				this.fillRequested = true;
			}
		}
		return false;
	}
}
gmdebug_dap_BytesProcessor.__name__ = "gmdebug.dap.BytesProcessor";
Object.assign(gmdebug_dap_BytesProcessor.prototype, {
	__class__: gmdebug_dap_BytesProcessor
	,fillRequested: null
	,prevClientResults: null
	,prevBytes: null
	,lastGoodPos: null
});
var gmdebug_dap_RecvMessageResponse = $hxEnums["gmdebug.dap.RecvMessageResponse"] = { __ename__:"gmdebug.dap.RecvMessageResponse",__constructs__:null
	,Completed: ($_=function(x) { return {_hx_index:0,x:x,__enum__:"gmdebug.dap.RecvMessageResponse",toString:$estr}; },$_._hx_name="Completed",$_.__params__ = ["x"],$_)
	,Unfinished: ($_=function(x,remaining) { return {_hx_index:1,x:x,remaining:remaining,__enum__:"gmdebug.dap.RecvMessageResponse",toString:$estr}; },$_._hx_name="Unfinished",$_.__params__ = ["x","remaining"],$_)
};
gmdebug_dap_RecvMessageResponse.__constructs__ = [gmdebug_dap_RecvMessageResponse.Completed,gmdebug_dap_RecvMessageResponse.Unfinished];
class gmdebug_dap_Client extends gmdebug_dap_BaseConnected {
	constructor(fs,clientID,gmodID,gmodName) {
		super(fs,clientID);
		this.gmodID = gmodID;
		this.gmodName = gmodName;
	}
}
gmdebug_dap_Client.__name__ = "gmdebug.dap.Client";
gmdebug_dap_Client.__super__ = gmdebug_dap_BaseConnected;
Object.assign(gmdebug_dap_Client.prototype, {
	__class__: gmdebug_dap_Client
	,gmodID: null
	,gmodName: null
});
class gmdebug_dap_ClientStorage {
	constructor(readFunc) {
		this.gmodIDMap = new haxe_ds_IntMap();
		this.disconnect = false;
		this.clients = [];
		this.readFunc = readFunc;
	}
	makePipeSocket(loc,id) {
		let _gthis = this;
		return tink_core_Future.irreversible(function(__return) {
			try {
				let data = haxe_io_Path.join([loc,gmdebug_Cross.DATA]);
				let input = haxe_io_Path.join([data,gmdebug_Cross.INPUT]);
				let output = haxe_io_Path.join([data,gmdebug_Cross.OUTPUT]);
				let ready = haxe_io_Path.join([data,gmdebug_Cross.READY]);
				let ps = new gmdebug_dap_PipeSocket({ read : output, write : input, ready : ready},function(buf) {
					_gthis.readFunc(buf,id);
				});
				ps.aquire().handle(function(__t2) {
					try {
						let _g = tink_await_OutcomeTools.getOutcome(__t2);
						switch(_g._hx_index) {
						case 0:
							break;
						case 1:
							__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g.failure)));
							return;
						}
						haxe_Log.trace("mega aquired",{ fileName : "src/gmdebug/dap/ClientStorage.hx", lineNumber : 51, className : "gmdebug.dap.ClientStorage", methodName : "makePipeSocket"});
						__return(tink_core_Outcome.Success(ps));
						return;
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						let _g1 = haxe_Exception.caught(_g).unwrap();
						__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
					}
				});
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
			}
		});
	}
	newClient(clientLoc,gmodID,gmodName) {
		let _gthis = this;
		return tink_core_Future.irreversible(function(__return) {
			try {
				let clID = _gthis.clients.length;
				_gthis.makePipeSocket(clientLoc,clID).handle(function(__t3) {
					try {
						let __t3_result;
						let _g = tink_await_OutcomeTools.getOutcome(__t3);
						switch(_g._hx_index) {
						case 0:
							__t3_result = _g.data;
							break;
						case 1:
							__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g.failure)));
							return;
						}
						let pipesocket = __t3_result;
						let client = new gmdebug_dap_Client(pipesocket,clID,gmodID,gmodName);
						_gthis.clients.push(client);
						haxe_Log.trace("client created",{ fileName : "src/gmdebug/dap/ClientStorage.hx", lineNumber : 61, className : "gmdebug.dap.ClientStorage", methodName : "newClient"});
						_gthis.gmodIDMap.h[gmodID] = client;
						__return(tink_core_Outcome.Success(client));
						return;
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						let _g1 = haxe_Exception.caught(_g).unwrap();
						__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
					}
				});
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
			}
		});
	}
	newServer(serverLoc) {
		let _gthis = this;
		return tink_core_Future.irreversible(function(__return) {
			try {
				let clID = gmdebug_dap_ClientStorage.SERVER_ID;
				_gthis.makePipeSocket(serverLoc,clID).handle(function(__t4) {
					try {
						let __t4_result;
						let _g = tink_await_OutcomeTools.getOutcome(__t4);
						switch(_g._hx_index) {
						case 0:
							__t4_result = _g.data;
							break;
						case 1:
							__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g.failure)));
							return;
						}
						let pipesocket = __t4_result;
						haxe_Log.trace("Server created",{ fileName : "src/gmdebug/dap/ClientStorage.hx", lineNumber : 69, className : "gmdebug.dap.ClientStorage", methodName : "newServer"});
						let server = new gmdebug_dap_Server(pipesocket,clID);
						_gthis.clients[gmdebug_dap_ClientStorage.SERVER_ID] = server;
						__return(tink_core_Outcome.Success(server));
						return;
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						let _g1 = haxe_Exception.caught(_g).unwrap();
						__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
					}
				});
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
			}
		});
	}
	sendServer(msg) {
		let tmp = this.clients[gmdebug_dap_ClientStorage.SERVER_ID];
		let json = haxe_format_JsonPrinter.print(msg,null,null);
		let len = haxe_io_Bytes.ofString(json).length;
		tmp.sendRaw("Content-Length: " + len + "\r\n\r\n" + json);
	}
	sendClient(id,msg) {
		if(id == gmdebug_dap_ClientStorage.SERVER_ID) {
			throw haxe_Exception.thrown("Attempt to send to server....");
		}
		let tmp = this.clients[id];
		let json = haxe_format_JsonPrinter.print(msg,null,null);
		let len = haxe_io_Bytes.ofString(json).length;
		tmp.sendRaw("Content-Length: " + len + "\r\n\r\n" + json);
	}
	getClients() {
		return this.clients.slice(1);
	}
	sendAll(msg) {
		let json = haxe_format_JsonPrinter.print(msg,null,null);
		let len = haxe_io_Bytes.ofString(json).length;
		let comp = "Content-Length: " + len + "\r\n\r\n" + json;
		Lambda.iter(this.clients,function(c) {
			c.sendRaw(comp);
		});
	}
	sendAny(id,msg) {
		let tmp = this.clients[id];
		let json = haxe_format_JsonPrinter.print(msg,null,null);
		let len = haxe_io_Bytes.ofString(json).length;
		tmp.sendRaw("Content-Length: " + len + "\r\n\r\n" + json);
	}
	sendAnyRaw(id,str) {
		this.clients[id].sendRaw(str);
	}
	getByGmodID(id) {
		return this.gmodIDMap.h[id];
	}
	disconnectAll() {
		this.disconnect = true;
		Lambda.iter(this.clients,function(c) {
			c.disconnect();
		});
	}
}
gmdebug_dap_ClientStorage.__name__ = "gmdebug.dap.ClientStorage";
Object.assign(gmdebug_dap_ClientStorage.prototype, {
	__class__: gmdebug_dap_ClientStorage
	,clients: null
	,disconnect: null
	,gmodIDMap: null
	,readFunc: null
});
class gmdebug_dap_DapFailureTools {
	static sendError(opt,req,luaDebug) {
		if(opt._hx_index == 0) {
			let _g = opt.v;
			let _this = gmdebug_composer_ComposeTools.composeFail(req,_g.message,{ id : _g.id, format : _g.message});
			haxe_Log.trace("sending from dap " + _this.command,{ fileName : "src/gmdebug/composer/ComposedResponse.hx", lineNumber : 51, className : "gmdebug.composer.ComposedResponse", methodName : "send"});
			luaDebug.sendResponse(_this);
			return true;
		} else {
			return false;
		}
	}
}
gmdebug_dap_DapFailureTools.__name__ = "gmdebug.dap.DapFailureTools";
class gmdebug_dap_EventIntercepter {
	static event(ceptedEvent,threadId,luaDebug) {
		switch(ceptedEvent.event) {
		case "output":
			let outputEvent = ceptedEvent;
			let prefix = threadId > 0 ? "[C] - " : "[S] - ";
			outputEvent.body.output = prefix + outputEvent.body.output;
			break;
		case "stopped":
			let stoppedEvent = ceptedEvent;
			if(luaDebug.programs.xdotool && stoppedEvent.body.threadId > 0) {
				haxe_Log.trace("free my mousepointer please!!",{ fileName : "src/gmdebug/dap/EventIntercepter.hx", lineNumber : 20, className : "gmdebug.dap.EventIntercepter", methodName : "event"});
				js_node_ChildProcess.execSync("xdotool key XF86Ungrab");
			}
			break;
		default:
		}
	}
}
gmdebug_dap_EventIntercepter.__name__ = "gmdebug.dap.EventIntercepter";
class gmdebug_dap_LaunchProcess {
	constructor(programPath,luaDebug,programArgs) {
		programArgs = programArgs == null ? [] : programArgs;
		let argString = "";
		let _g = 0;
		while(_g < programArgs.length) {
			let arg = programArgs[_g];
			++_g;
			argString += arg + " ";
		}
		this.childProcess = js_node_ChildProcess.spawn("script -c '" + programPath + " -norestart " + argString + " +sv_hibernate_think 1' /dev/null",{ cwd : haxe_io_Path.directory(programPath), env : process.env, shell : true});
		this.childProcess.stdout.on("data",function(str) {
			let _this = new gmdebug_composer_ComposedEvent("output",{ category : "stdout", output : StringTools.replace(str.toString(),"\r",""), data : null});
			haxe_Log.trace("sending from dap " + _this.event,{ fileName : "src/gmdebug/composer/ComposedEvent.hx", lineNumber : 26, className : "gmdebug.composer.ComposedEvent", methodName : "send"});
			luaDebug.sendEvent(_this);
		});
		this.childProcess.stderr.on("data",function(str) {
			let _this = new gmdebug_composer_ComposedEvent("output",{ category : "stdout", output : str.toString(), data : null});
			haxe_Log.trace("sending from dap " + _this.event,{ fileName : "src/gmdebug/composer/ComposedEvent.hx", lineNumber : 26, className : "gmdebug.composer.ComposedEvent", methodName : "send"});
			luaDebug.sendEvent(_this);
		});
		this.childProcess.on("error",function(err) {
			let _this = new gmdebug_composer_ComposedEvent("output",{ category : "stderr", output : err.message + "\n" + err.stack, data : null});
			haxe_Log.trace("sending from dap " + _this.event,{ fileName : "src/gmdebug/composer/ComposedEvent.hx", lineNumber : 26, className : "gmdebug.composer.ComposedEvent", methodName : "send"});
			luaDebug.sendEvent(_this);
			haxe_Log.trace("Child process error///",{ fileName : "src/gmdebug/dap/LaunchProcess.hx", lineNumber : 45, className : "gmdebug.dap.LaunchProcess", methodName : "new"});
			haxe_Log.trace(err.message,{ fileName : "src/gmdebug/dap/LaunchProcess.hx", lineNumber : 46, className : "gmdebug.dap.LaunchProcess", methodName : "new"});
			haxe_Log.trace(err.stack,{ fileName : "src/gmdebug/dap/LaunchProcess.hx", lineNumber : 47, className : "gmdebug.dap.LaunchProcess", methodName : "new"});
			haxe_Log.trace("Child process error end///",{ fileName : "src/gmdebug/dap/LaunchProcess.hx", lineNumber : 48, className : "gmdebug.dap.LaunchProcess", methodName : "new"});
			luaDebug.shutdown();
		});
	}
	write(chunk) {
		this.childProcess.stdin.write(chunk);
	}
	kill() {
		this.childProcess.kill();
	}
}
gmdebug_dap_LaunchProcess.__name__ = "gmdebug.dap.LaunchProcess";
Object.assign(gmdebug_dap_LaunchProcess.prototype, {
	__class__: gmdebug_dap_LaunchProcess
	,childProcess: null
});
var vscode_debugAdapter_DebugSession = require("vscode-debugadapter").DebugSession;
class gmdebug_dap_LuaDebugger extends vscode_debugAdapter_DebugSession {
	constructor(x,y) {
		super(x,y);
		this.clientLocations = [];
		this.serverFolder = null;
		this.clientsTaken = new haxe_ds_IntMap();
		this.dapMode = gmdebug_dap_DapMode.ATTACH;
		this.commMethod = gmdebug_CommMethod.Pipe;
		this.programs = { xdotool : false};
		this.bytesProcessor = new gmdebug_dap_BytesProcessor();
		this.prevRequests = new gmdebug_dap_PreviousRequests();
		this.clients = new gmdebug_dap_ClientStorage($bind(this,this.readGmodBuffer));
		this.requestRouter = new gmdebug_dap_RequestRouter(this,this.clients,this.prevRequests);
		process.on("uncaughtException",$bind(this,this.uncaughtException));
		this.checkPrograms();
	}
	checkPrograms() {
		try {
			js_node_ChildProcess.execSync("xdotool");
			this.programs.xdotool = true;
		} catch( _g ) {
			haxe_Log.trace("Xdotool not found",{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 85, className : "gmdebug.dap.LuaDebugger", methodName : "checkPrograms"});
		}
	}
	uncaughtException(err,origin) {
		haxe_Log.trace(err.message,{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 90, className : "gmdebug.dap.LuaDebugger", methodName : "uncaughtException"});
		haxe_Log.trace(err.stack,{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 91, className : "gmdebug.dap.LuaDebugger", methodName : "uncaughtException"});
		this.shutdown();
	}
	playerAddedMessage(x) {
		let _gthis = this;
		return tink_core_Future.irreversible(function(__return) {
			try {
				let success = false;
				let _this = _gthis.clientLocations;
				let _g_current = 0;
				while(_g_current < _this.length) {
					let _g1_value = _this[_g_current];
					let _g1_key = _g_current++;
					if(!_gthis.clientsTaken.h.hasOwnProperty(_g1_key)) {
						try {
							let this1 = _gthis.playerTry(_g1_value,x.playerID,x.name);
							this1.eager();
							success = true;
							break;
						} catch( _g ) {
							haxe_Log.trace("could not aquire in " + _g1_value,{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 105, className : "gmdebug.dap.LuaDebugger", methodName : "playerAddedMessage"});
						}
					}
				}
				__return(tink_core_Outcome.Success(success));
				return;
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(haxe_Exception.caught(_g).unwrap())));
			}
		});
	}
	playerTry(clientLoc,gmodID,playerName) {
		let _gthis = this;
		return tink_core_Future.irreversible(function(__return) {
			try {
				_gthis.clients.newClient(clientLoc,gmodID,playerName).handle(function(__t0) {
					try {
						let __t0_result;
						let _g = tink_await_OutcomeTools.getOutcome(__t0);
						switch(_g._hx_index) {
						case 0:
							__t0_result = _g.data;
							break;
						case 1:
							__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g.failure)));
							return;
						}
						let cl = __t0_result;
						let _this = new gmdebug_composer_ComposedEvent("thread",{ threadId : cl.clID, reason : "started"});
						haxe_Log.trace("sending from dap " + _this.event,{ fileName : "src/gmdebug/composer/ComposedEvent.hx", lineNumber : 26, className : "gmdebug.composer.ComposedEvent", methodName : "send"});
						_gthis.sendEvent(_this);
						_gthis.setupPlayer(cl.clID);
						__return(tink_core_Outcome.Success(null));
						return;
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						let _g1 = haxe_Exception.caught(_g).unwrap();
						__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
					}
				});
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
			}
		});
	}
	setupPlayer(clientID) {
		this.clients.sendClient(clientID,new gmdebug_composer_ComposedGmDebugMessage(3,{ location : this.serverFolder, dapMode : "Launch"}));
		this.clients.sendClient(clientID,new gmdebug_composer_ComposedGmDebugMessage(2,{ id : clientID}));
		let value = this.prevRequests.get("setBreakpoints");
		if(value != null) {
			this.clients.sendClient(clientID,value);
		}
		let value1 = this.prevRequests.get("setExceptionBreakpoints");
		if(value1 != null) {
			this.clients.sendClient(clientID,value1);
		}
		let value2 = this.prevRequests.get("setFunctionBreakpoints");
		if(value2 != null) {
			this.clients.sendClient(clientID,value2);
		}
		this.clients.sendClient(clientID,new gmdebug_composer_ComposedRequest("configurationDone",{ }));
	}
	playerRemovedMessage(x) {
		let _this = new gmdebug_composer_ComposedEvent("thread",{ threadId : this.clients.getByGmodID(x.playerID).clID, reason : "exited"});
		haxe_Log.trace("sending from dap " + _this.event,{ fileName : "src/gmdebug/composer/ComposedEvent.hx", lineNumber : 26, className : "gmdebug.composer.ComposedEvent", methodName : "send"});
		this.sendEvent(_this);
		this.clientsTaken.remove(this.clients.getByGmodID(x.playerID).clID);
	}
	serverInfoMessage(x) {
		let sp = x.ip.split(":");
		let ip = x.isLan ? gmdebug_lib_js_Ip.address() : sp[0];
		let port = sp[1];
		js_node_ChildProcess.spawn("xdg-open steam://connect/" + ip + ":" + port,{ shell : true});
	}
	processCustomMessages(x) {
		haxe_Log.trace("custom message",{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 154, className : "gmdebug.dap.LuaDebugger", methodName : "processCustomMessages"});
		switch(x.msg) {
		case 0:
			this.playerAddedMessage(x.body).handle(function(out) {
				switch(out._hx_index) {
				case 0:
					if(out.data) {
						haxe_Log.trace("Whater a sucess",{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 160, className : "gmdebug.dap.LuaDebugger", methodName : "processCustomMessages"});
					} else {
						haxe_Log.trace("Could not add a new player...",{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 162, className : "gmdebug.dap.LuaDebugger", methodName : "processCustomMessages"});
					}
					break;
				case 1:
					throw haxe_Exception.thrown(out.failure);
				}
			});
			break;
		case 1:
			this.playerRemovedMessage(x.body);
			break;
		case 2:case 3:
			throw haxe_Exception.thrown("dur");
		case 4:
			this.serverInfoMessage(x.body);
			break;
		}
	}
	pokeServerNamedPipes(attachReq) {
		let _gthis = this;
		return tink_core_Future.irreversible(function(__return) {
			try {
				_gthis.clients.newServer(attachReq.arguments.serverFolder).handle(function(__t1) {
					try {
						let _g = tink_await_OutcomeTools.getOutcome(__t1);
						switch(_g._hx_index) {
						case 0:
							break;
						case 1:
							__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g.failure)));
							return;
						}
						_gthis.clients.sendServer(new gmdebug_composer_ComposedGmDebugMessage(2,{ id : 0}));
						switch(_gthis.dapMode._hx_index) {
						case 0:
							_gthis.clients.sendServer(new gmdebug_composer_ComposedGmDebugMessage(3,{ location : _gthis.serverFolder, dapMode : "Attach"}));
							break;
						case 1:
							_gthis.clients.sendServer(new gmdebug_composer_ComposedGmDebugMessage(3,{ location : _gthis.serverFolder, dapMode : "Launch"}));
							break;
						}
						__return(tink_core_Outcome.Success(null));
						return;
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						let _g1 = haxe_Exception.caught(_g).unwrap();
						__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
					}
				});
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
			}
		});
	}
	makeFifosIfNotExist(input,output) {
		if(!sys_FileSystem.exists(input) && !sys_FileSystem.exists(output)) {
			js_node_ChildProcess.execSync("mkfifo " + input);
			js_node_ChildProcess.execSync("mkfifo " + output);
			js_node_Fs.chmodSync(input,"744");
			js_node_Fs.chmodSync(output,"722");
		}
	}
	readGmodBuffer(jsBuf,clientNo) {
		let messages = this.bytesProcessor.process(jsBuf,clientNo);
		let _g = 0;
		while(_g < messages.length) {
			let msg = messages[_g];
			++_g;
			this.processDebugeeMessage(msg,clientNo);
		}
		if(this.bytesProcessor.fillRequested) {
			this.clients.sendAnyRaw(clientNo,"\x04\r\n");
		}
	}
	processDebugeeMessage(debugeeMessage,threadId) {
		debugeeMessage.seq = 0;
		switch(debugeeMessage.type) {
		case "event":
			let cmd = debugeeMessage.event;
			haxe_Log.trace("recieved event from debugee, " + cmd,{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 214, className : "gmdebug.dap.LuaDebugger", methodName : "processDebugeeMessage"});
			gmdebug_dap_EventIntercepter.event(debugeeMessage,threadId,this);
			this.sendEvent(debugeeMessage);
			break;
		case "gmdebug":
			let cmd1 = debugeeMessage.msg;
			haxe_Log.trace("recieved gmdebug from debugee, " + cmd1,{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 223, className : "gmdebug.dap.LuaDebugger", methodName : "processDebugeeMessage"});
			this.processCustomMessages(debugeeMessage);
			break;
		case "response":
			let cmd2 = debugeeMessage.command;
			haxe_Log.trace("recieved response from debugee, " + cmd2,{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 219, className : "gmdebug.dap.LuaDebugger", methodName : "processDebugeeMessage"});
			this.sendResponse(debugeeMessage);
			break;
		default:
			throw haxe_Exception.thrown("unhandled");
		}
	}
	shutdown() {
		let _g = this.dapMode;
		if(_g._hx_index == 1) {
			let _g1 = _g.child;
			_g1.write("quit\n");
			_g1.kill();
		}
		this.clients.disconnectAll();
		super.shutdown();
	}
	startServer(attachReq) {
		let _gthis = this;
		this.pokeServerNamedPipes(attachReq).handle(function(out) {
			switch(out._hx_index) {
			case 0:
				haxe_Log.trace("Attatch success",{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 250, className : "gmdebug.dap.LuaDebugger", methodName : "startServer"});
				let resp = gmdebug_composer_ComposeTools.compose(attachReq,"attach");
				haxe_Log.trace("sending from dap " + resp.command,{ fileName : "src/gmdebug/composer/ComposedResponse.hx", lineNumber : 51, className : "gmdebug.composer.ComposedResponse", methodName : "send"});
				_gthis.sendResponse(resp);
				break;
			case 1:
				let _g = out.failure;
				haxe_Log.trace(_g.message,{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 254, className : "gmdebug.dap.LuaDebugger", methodName : "startServer"});
				let resp1 = gmdebug_composer_ComposeTools.composeFail(attachReq,"attach fail " + _g.message,{ id : 1, format : "Failed to attach to server " + _g.message});
				haxe_Log.trace("sending from dap " + resp1.command,{ fileName : "src/gmdebug/composer/ComposedResponse.hx", lineNumber : 51, className : "gmdebug.composer.ComposedResponse", methodName : "send"});
				_gthis.sendResponse(resp1);
				break;
			}
		});
	}
	setClientLocations(a) {
		return this.clientLocations = a;
	}
	handleMessage(message) {
		if(message.type == "request") {
			haxe_Log.trace("recieved request from client " + message.command,{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 272, className : "gmdebug.dap.LuaDebugger", methodName : "handleMessage"});
			this.requestRouter.route(message);
		} else {
			haxe_Log.trace("not a request from client",{ fileName : "src/gmdebug/dap/LuaDebugger.hx", lineNumber : 275, className : "gmdebug.dap.LuaDebugger", methodName : "handleMessage"});
		}
	}
}
gmdebug_dap_LuaDebugger.__name__ = "gmdebug.dap.LuaDebugger";
gmdebug_dap_LuaDebugger.__super__ = vscode_debugAdapter_DebugSession;
Object.assign(gmdebug_dap_LuaDebugger.prototype, {
	__class__: gmdebug_dap_LuaDebugger
	,commMethod: null
	,clientFiles: null
	,dapMode: null
	,serverFolder: null
	,clientsTaken: null
	,programs: null
	,requestRouter: null
	,clientLocations: null
	,bytesProcessor: null
	,prevRequests: null
	,clients: null
});
var gmdebug_dap_DapMode = $hxEnums["gmdebug.dap.DapMode"] = { __ename__:"gmdebug.dap.DapMode",__constructs__:null
	,ATTACH: {_hx_name:"ATTACH",_hx_index:0,__enum__:"gmdebug.dap.DapMode",toString:$estr}
	,LAUNCH: ($_=function(child) { return {_hx_index:1,child:child,__enum__:"gmdebug.dap.DapMode",toString:$estr}; },$_._hx_name="LAUNCH",$_.__params__ = ["child"],$_)
};
gmdebug_dap_DapMode.__constructs__ = [gmdebug_dap_DapMode.ATTACH,gmdebug_dap_DapMode.LAUNCH];
class gmdebug_dap_PipeSocket {
	constructor(locs,readFunc) {
		this.aquired = false;
		this.locs = locs;
		this.readFunc = readFunc;
	}
	aquire() {
		let _gthis = this;
		return tink_core_Future.irreversible(function(__return) {
			try {
				_gthis.makeFifosIfNotExist(_gthis.locs.read,_gthis.locs.write);
				_gthis.aquireReadSocket(_gthis.locs.read).handle(function(__t5) {
					try {
						let __t5_result;
						let _g = tink_await_OutcomeTools.getOutcome(__t5);
						switch(_g._hx_index) {
						case 0:
							__t5_result = _g.data;
							break;
						case 1:
							__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g.failure)));
							return;
						}
						_gthis.readS = __t5_result;
						_gthis.aquireWriteSocket(_gthis.locs.write).handle(function(__t6) {
							try {
								let __t6_result;
								let _g = tink_await_OutcomeTools.getOutcome(__t6);
								switch(_g._hx_index) {
								case 0:
									__t6_result = _g.data;
									break;
								case 1:
									__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g.failure)));
									return;
								}
								_gthis.writeS = __t6_result;
								js_node_Fs.writeFileSync(_gthis.locs.ready,"");
								_gthis.writeS.write("\x04\r\n");
								_gthis.readS.on("data",_gthis.readFunc);
								_gthis.aquired = true;
								haxe_Log.trace("Aquired socket...",{ fileName : "src/gmdebug/dap/PipeSocket.hx", lineNumber : 45, className : "gmdebug.dap.PipeSocket", methodName : "aquire"});
								__return(tink_core_Outcome.Success(null));
								return;
							} catch( _g ) {
								haxe_NativeStackTrace.lastError = _g;
								let _g1 = haxe_Exception.caught(_g).unwrap();
								__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
							}
						});
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						let _g1 = haxe_Exception.caught(_g).unwrap();
						__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
					}
				});
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
			}
		});
	}
	makeFifosIfNotExist(input,output) {
		if(!sys_FileSystem.exists(input) && !sys_FileSystem.exists(output)) {
			js_node_ChildProcess.execSync("mkfifo " + input);
			js_node_ChildProcess.execSync("mkfifo " + output);
			js_node_Fs.chmodSync(input,"744");
			js_node_Fs.chmodSync(output,"722");
		}
	}
	aquireReadSocket(out) {
		return tink_core_Future.irreversible(function(__return) {
			try {
				let open = js_node_util_Promisify(js_node_Fs.open);
				tink_core_Future.ofJsPromise(open(out,js_node_Fs.constants.O_RDONLY | js_node_Fs.constants.O_NONBLOCK)).handle(function(__t7) {
					try {
						let __t7_result;
						let _g = tink_await_OutcomeTools.getOutcome(__t7);
						switch(_g._hx_index) {
						case 0:
							__t7_result = _g.data;
							break;
						case 1:
							__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g.failure)));
							return;
						}
						let fd = __t7_result;
						__return(tink_core_Outcome.Success(new js_node_net_Socket({ fd : fd, writable : false})));
						return;
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						let _g1 = haxe_Exception.caught(_g).unwrap();
						__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
					}
				});
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
			}
		});
	}
	aquireWriteSocket(inp) {
		return tink_core_Future.irreversible(function(__return) {
			try {
				let open = js_node_util_Promisify(js_node_Fs.open);
				tink_core_Future.ofJsPromise(open(inp,js_node_Fs.constants.O_RDWR | js_node_Fs.constants.O_NONBLOCK)).handle(function(__t8) {
					try {
						let __t8_result;
						let _g = tink_await_OutcomeTools.getOutcome(__t8);
						switch(_g._hx_index) {
						case 0:
							__t8_result = _g.data;
							break;
						case 1:
							__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g.failure)));
							return;
						}
						let fd = __t8_result;
						haxe_Log.trace(fd,{ fileName : "src/gmdebug/dap/PipeSocket.hx", lineNumber : 67, className : "gmdebug.dap.PipeSocket", methodName : "aquireWriteSocket"});
						__return(tink_core_Outcome.Success(new js_node_net_Socket({ fd : fd, readable : false})));
						return;
					} catch( _g ) {
						haxe_NativeStackTrace.lastError = _g;
						let _g1 = haxe_Exception.caught(_g).unwrap();
						__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
					}
				});
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				__return(tink_core_Outcome.Failure(tink_core_TypedError.asError(_g1)));
			}
		});
	}
	write(chunk) {
		this.writeS.write(chunk);
	}
	end() {
		this.readS.end();
		this.writeS.end();
		js_node_Fs.unlinkSync(this.locs.read);
		js_node_Fs.unlinkSync(this.locs.write);
	}
}
gmdebug_dap_PipeSocket.__name__ = "gmdebug.dap.PipeSocket";
Object.assign(gmdebug_dap_PipeSocket.prototype, {
	__class__: gmdebug_dap_PipeSocket
	,writeS: null
	,readS: null
	,locs: null
	,aquired: null
	,readFunc: null
});
class gmdebug_dap_PreviousRequests {
	constructor() {
		this.prevRequestMap = new haxe_ds_StringMap();
	}
	update(req) {
		this.prevRequestMap.h[req.command] = req;
	}
	get(command) {
		return this.prevRequestMap.h[command];
	}
}
gmdebug_dap_PreviousRequests.__name__ = "gmdebug.dap.PreviousRequests";
Object.assign(gmdebug_dap_PreviousRequests.prototype, {
	__class__: gmdebug_dap_PreviousRequests
	,prevRequestMap: null
});
class gmdebug_dap_RequestRouter {
	constructor(luaDebug,clients,prevRequests) {
		this.luaDebug = luaDebug;
		this.clients = clients;
		this.prevRequests = prevRequests;
	}
	route(req) {
		let command = req.command;
		switch(command) {
		case "attach":
			this.h_attach(req);
			break;
		case "configurationDone":
			this.clients.sendServer(req);
			break;
		case "disconnect":
			this.h_disconnect(req);
			break;
		case "evaluate":
			this.h_evaluate(req);
			break;
		case "breakpointLocations":case "goto":case "gotoTargets":case "loadedSources":case "modules":
			this.clients.sendServer(req);
			break;
		case "initialize":
			this.h_initialize(req);
			break;
		case "launch":
			this.h_launch(req);
			break;
		case "scopes":
			this.h_scopes(req);
			break;
		case "setBreakpoints":
			this.prevRequests.update(req);
			this.clients.sendAll(req);
			break;
		case "setExceptionBreakpoints":
			this.prevRequests.update(req);
			this.clients.sendAll(req);
			break;
		case "setFunctionBreakpoints":
			this.prevRequests.update(req);
			this.clients.sendAll(req);
			break;
		case "continue":case "next":case "pause":case "stackTrace":case "stepIn":case "stepOut":
			let id = req.arguments.threadId;
			this.clients.sendAny(id,req);
			break;
		case "threads":
			this.h_threads(req);
			break;
		case "variables":
			this.h_variables(req);
			break;
		}
	}
	h_threads(req) {
		let threadArr = [{ name : "Server", id : 0}];
		let _g = 0;
		let _g1 = this.clients.getClients();
		while(_g < _g1.length) {
			let cl = _g1[_g];
			++_g;
			threadArr.push({ name : cl.gmodName, id : cl.clID});
		}
		let _this = gmdebug_composer_ComposeTools.compose(req,"threads",{ threads : threadArr});
		let luaDebug = this.luaDebug;
		haxe_Log.trace("sending from dap " + _this.command,{ fileName : "src/gmdebug/composer/ComposedResponse.hx", lineNumber : 51, className : "gmdebug.composer.ComposedResponse", methodName : "send"});
		luaDebug.sendResponse(_this);
	}
	h_disconnect(req) {
		this.clients.sendAll(req);
		let _this = gmdebug_composer_ComposeTools.compose(req,"disconnect");
		let luaDebug = this.luaDebug;
		haxe_Log.trace("sending from dap " + _this.command,{ fileName : "src/gmdebug/composer/ComposedResponse.hx", lineNumber : 51, className : "gmdebug.composer.ComposedResponse", methodName : "send"});
		luaDebug.sendResponse(_this);
		this.luaDebug.shutdown();
	}
	h_variables(req) {
		let ref = req.arguments.variablesReference;
		if(ref <= 0) {
			haxe_Log.trace("invalid variable reference",{ fileName : "src/gmdebug/dap/RequestRouter.hx", lineNumber : 95, className : "gmdebug.dap.RequestRouter", methodName : "h_variables"});
			let _this = gmdebug_composer_ComposeTools.compose(req,"variables",{ variables : []});
			let luaDebug = this.luaDebug;
			haxe_Log.trace("sending from dap " + _this.command,{ fileName : "src/gmdebug/composer/ComposedResponse.hx", lineNumber : 51, className : "gmdebug.composer.ComposedResponse", methodName : "send"});
			luaDebug.sendResponse(_this);
			return;
		}
		let _g = gmdebug_VariableReference.getValue(ref);
		switch(_g._hx_index) {
		case 0:
			this.clients.sendAny(_g.clientID,req);
			break;
		case 1:
			this.clients.sendAny(_g.clientID,req);
			break;
		case 2:
			this.clients.sendAny(_g.clientID,req);
			break;
		}
	}
	h_evaluate(req) {
		let expr = req.arguments.expression;
		if(expr.charAt(0) == "/") {
			let _g = this.luaDebug.dapMode;
			if(_g._hx_index == 1) {
				let actual = HxOverrides.substr(expr,1,null);
				_g.child.write(actual + "\n");
				let _this = gmdebug_composer_ComposeTools.compose(req,"evaluate",{ result : "", variablesReference : 0});
				let luaDebug = this.luaDebug;
				haxe_Log.trace("sending from dap " + _this.command,{ fileName : "src/gmdebug/composer/ComposedResponse.hx", lineNumber : 51, className : "gmdebug.composer.ComposedResponse", methodName : "send"});
				luaDebug.sendResponse(_this);
				return;
			}
		}
		let _g = req.arguments.frameId;
		let client = _g == null ? 0 : gmdebug_FrameID.getValue(_g).clientID;
		this.clients.sendAny(client,req);
	}
	h_initialize(req) {
		let response = { seq : 0, request_seq : req.seq, command : "initialize", type : "response", body : { }, success : true};
		response.body.supportsConfigurationDoneRequest = true;
		response.body.supportsFunctionBreakpoints = true;
		response.body.supportsConditionalBreakpoints = true;
		response.body.supportsEvaluateForHovers = true;
		response.body.supportsLoadedSourcesRequest = true;
		response.body.supportsFunctionBreakpoints = true;
		response.body.supportsDelayedStackTraceLoading = true;
		response.body.supportsBreakpointLocationsRequest = false;
		this.luaDebug.sendResponse(response);
	}
	h_launch(req) {
		let serverFolder = req.arguments.serverFolder;
		let serverFolderResult = this.validateServerFolder(serverFolder);
		if(serverFolderResult != haxe_ds_Option.None) {
			gmdebug_dap_DapFailureTools.sendError(serverFolderResult,req,this.luaDebug);
			return;
		}
		let programPath;
		let _g = req.arguments.programPath;
		if(_g == null) {
			let _this = gmdebug_composer_ComposeTools.composeFail(req,"Gmdebug requires the property \"programPath\" to be specified when launching.",{ id : 2, format : "Gmdebug requires the property \"programPath\" to be specified when launching"});
			let luaDebug = this.luaDebug;
			haxe_Log.trace("sending from dap " + _this.command,{ fileName : "src/gmdebug/composer/ComposedResponse.hx", lineNumber : 51, className : "gmdebug.composer.ComposedResponse", methodName : "send"});
			luaDebug.sendResponse(_this);
			return;
		} else {
			programPath = _g == "auto" ? "" + serverFolder + "/../srcds_run" : _g;
		}
		let programPathResult = this.validateProgramPath(programPath);
		if(programPathResult != haxe_ds_Option.None) {
			gmdebug_dap_DapFailureTools.sendError(programPathResult,req,this.luaDebug);
			return;
		}
		let childProcess = new gmdebug_dap_LaunchProcess(programPath,this.luaDebug,req.arguments.programArgs);
		this.copyLuaFiles(serverFolder);
		let value = req.arguments.clientFolders;
		let clientFolders = value == null ? [] : value;
		let _g1_current = 0;
		let _g1_array = clientFolders;
		while(_g1_current < _g1_array.length) {
			let _g2_value = _g1_array[_g1_current];
			let _g2_key = _g1_current++;
			let clientFolderResult = this.validateClientFolder(_g2_value);
			if(clientFolderResult != haxe_ds_Option.None) {
				gmdebug_dap_DapFailureTools.sendError(clientFolderResult,req,this.luaDebug);
				return;
			}
			clientFolders[_g2_key] = haxe_io_Path.addTrailingSlash(_g2_value);
		}
		let serverSlash = haxe_io_Path.addTrailingSlash(req.arguments.serverFolder);
		this.luaDebug.serverFolder = serverSlash;
		this.luaDebug.setClientLocations(clientFolders);
		this.luaDebug.dapMode = gmdebug_dap_DapMode.LAUNCH(childProcess);
		this.luaDebug.startServer(req);
	}
	h_scopes(req) {
		let client = gmdebug_FrameID.getValue(req.arguments.frameId).clientID;
		this.clients.sendAny(client,req);
	}
	copyLuaFiles(serverFolder) {
		let addonFolder = haxe_io_Path.join([serverFolder,"addons"]);
		haxe_io_Path.join([addonFolder,"debugee"]);
		js_node_ChildProcess.execSync("cp -r ../generated/debugee " + addonFolder,{ cwd : haxe_io_Path.directory(__filename)});
	}
	h_attach(req) {
		let serverFolder = req.arguments.serverFolder;
		let serverFolderResult = this.validateServerFolder(serverFolder);
		if(serverFolderResult != haxe_ds_Option.None) {
			gmdebug_dap_DapFailureTools.sendError(serverFolderResult,req,this.luaDebug);
			return;
		}
		let value = req.arguments.clientFolders;
		let clientFolders = value == null ? [] : value;
		let _g_current = 0;
		let _g_array = clientFolders;
		while(_g_current < _g_array.length) {
			let _g1_value = _g_array[_g_current];
			let _g1_key = _g_current++;
			let clientFolderResult = this.validateClientFolder(_g1_value);
			if(clientFolderResult != haxe_ds_Option.None) {
				gmdebug_dap_DapFailureTools.sendError(clientFolderResult,req,this.luaDebug);
				return;
			}
			clientFolders[_g1_key] = haxe_io_Path.addTrailingSlash(_g1_value);
		}
		let serverSlash = haxe_io_Path.addTrailingSlash(req.arguments.serverFolder);
		this.luaDebug.serverFolder = serverSlash;
		this.luaDebug.setClientLocations(clientFolders);
		this.luaDebug.startServer(req);
	}
	validateProgramPath(programPath) {
		if(programPath == null) {
			return haxe_ds_Option.Some({ id : 2, message : "Gmdebug requires the property \"programPath\" to be specified when launching"});
		} else if(!js_node_Fs.existsSync(programPath)) {
			return haxe_ds_Option.Some({ id : 4, message : "The program specified by \"programPath\" does not exist!"});
		} else if(!js_node_Fs.statSync(programPath).isFile()) {
			return haxe_ds_Option.Some({ id : 5, message : "The program specified by \"programPath\" is not a file."});
		} else {
			return haxe_ds_Option.None;
		}
	}
	validateServerFolder(serverFolder) {
		if(serverFolder == null) {
			return haxe_ds_Option.Some({ id : 2, message : "Gmdebug requires the property \"serverFolder\" to be specified."});
		} else {
			let addonFolder = js_node_Path.join(serverFolder,"addons");
			if(!haxe_io_Path.isAbsolute(serverFolder)) {
				return haxe_ds_Option.Some({ id : 3, message : "Gmdebug requires the property \"serverFolder\" to be an absolute path (i.e from root folder)."});
			} else if(!js_node_Fs.existsSync(serverFolder)) {
				return haxe_ds_Option.Some({ id : 4, message : "The \"serverFolder\" path does not exist!"});
			} else if(!js_node_Fs.statSync(serverFolder).isDirectory()) {
				return haxe_ds_Option.Some({ id : 5, message : "The \"serverFolder\" path is not a directory."});
			} else if(!js_node_Fs.existsSync(addonFolder) || !js_node_Fs.statSync(addonFolder).isDirectory()) {
				return haxe_ds_Option.Some({ id : 6, message : "\"serverFolder\" does not seem to be a garrysmod directory. (looking for \"addons\" folder)"});
			} else {
				return haxe_ds_Option.None;
			}
		}
	}
	validateClientFolder(folder) {
		let addonFolder = js_node_Path.join(folder,"addons");
		js_node_Path.join(folder,"data","gmdebug");
		if(!haxe_io_Path.isAbsolute(folder)) {
			return haxe_ds_Option.Some({ id : 8, message : "Gmdebug requires client folder: " + folder + " to be an absolute path (i.e from root folder)."});
		} else if(!js_node_Fs.existsSync(folder)) {
			return haxe_ds_Option.Some({ id : 9, message : "The client folder: " + folder + " does not exist!"});
		} else if(!js_node_Fs.statSync(folder).isDirectory()) {
			return haxe_ds_Option.Some({ id : 10, message : "The client folder: " + folder + " is not a directory."});
		} else if(!js_node_Fs.existsSync(addonFolder) || !js_node_Fs.statSync(addonFolder).isDirectory()) {
			return haxe_ds_Option.Some({ id : 11, message : "The client folder: " + folder + " does not seem to be a garrysmod directory. (looking for \"addons\" folder)"});
		} else {
			return haxe_ds_Option.None;
		}
	}
}
gmdebug_dap_RequestRouter.__name__ = "gmdebug.dap.RequestRouter";
Object.assign(gmdebug_dap_RequestRouter.prototype, {
	__class__: gmdebug_dap_RequestRouter
	,luaDebug: null
	,clients: null
	,prevRequests: null
});
class gmdebug_dap_Server extends gmdebug_dap_BaseConnected {
	constructor(fs,clID) {
		super(fs,clID);
	}
}
gmdebug_dap_Server.__name__ = "gmdebug.dap.Server";
gmdebug_dap_Server.__super__ = gmdebug_dap_BaseConnected;
Object.assign(gmdebug_dap_Server.prototype, {
	__class__: gmdebug_dap_Server
});
var gmdebug_lib_js_Ip = require("ip");
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:"haxe.StackItem",__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
class haxe_CallStack {
	static callStack() {
		return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
	}
	static exceptionStack(fullStack) {
		if(fullStack == null) {
			fullStack = false;
		}
		let eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack());
		return fullStack ? eStack : haxe_CallStack.subtract(eStack,haxe_CallStack.callStack());
	}
	static toString(stack) {
		let b = new StringBuf();
		let _g = 0;
		let _g1 = stack;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			b.b += "\nCalled from ";
			haxe_CallStack.itemToString(b,s);
		}
		return b.b;
	}
	static subtract(this1,stack) {
		let startIndex = -1;
		let i = -1;
		while(++i < this1.length) {
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let j = _g++;
				if(haxe_CallStack.equalItems(this1[i],stack[j])) {
					if(startIndex < 0) {
						startIndex = i;
					}
					++i;
					if(i >= this1.length) {
						break;
					}
				} else {
					startIndex = -1;
				}
			}
			if(startIndex >= 0) {
				break;
			}
		}
		if(startIndex >= 0) {
			return this1.slice(0,startIndex);
		} else {
			return this1;
		}
	}
	static equalItems(item1,item2) {
		if(item1 == null) {
			if(item2 == null) {
				return true;
			} else {
				return false;
			}
		} else {
			switch(item1._hx_index) {
			case 0:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 0) {
					return true;
				} else {
					return false;
				}
				break;
			case 1:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 1) {
					return item1.m == item2.m;
				} else {
					return false;
				}
				break;
			case 2:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 2) {
					if(item1.file == item2.file && item1.line == item2.line && item1.column == item2.column) {
						return haxe_CallStack.equalItems(item1.s,item2.s);
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 3:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 3) {
					if(item1.classname == item2.classname) {
						return item1.method == item2.method;
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 4:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 4) {
					return item1.v == item2.v;
				} else {
					return false;
				}
				break;
			}
		}
	}
	static itemToString(b,s) {
		switch(s._hx_index) {
		case 0:
			b.b += "a C function";
			break;
		case 1:
			let _g = s.m;
			b.b = (b.b += "module ") + (_g == null ? "null" : "" + _g);
			break;
		case 2:
			let _g1 = s.s;
			let _g2 = s.file;
			let _g3 = s.line;
			let _g4 = s.column;
			if(_g1 != null) {
				haxe_CallStack.itemToString(b,_g1);
				b.b += " (";
			}
			b.b = (b.b += _g2 == null ? "null" : "" + _g2) + " line ";
			b.b += _g3 == null ? "null" : "" + _g3;
			if(_g4 != null) {
				b.b = (b.b += " column ") + (_g4 == null ? "null" : "" + _g4);
			}
			if(_g1 != null) {
				b.b += ")";
			}
			break;
		case 3:
			let _g5 = s.classname;
			let _g6 = s.method;
			b.b = (b.b += Std.string(_g5 == null ? "<unknown>" : _g5)) + ".";
			b.b += _g6 == null ? "null" : "" + _g6;
			break;
		case 4:
			let _g7 = s.v;
			b.b = (b.b += "local function #") + (_g7 == null ? "null" : "" + _g7);
			break;
		}
	}
}
class haxe_IMap {
}
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
Object.assign(haxe_IMap.prototype, {
	__class__: haxe_IMap
	,get: null
	,keys: null
});
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
		this.__skipStack = 0;
		let old = Error.prepareStackTrace;
		Error.prepareStackTrace = function(e) { return e.stack; }
		if(((native) instanceof Error)) {
			this.stack = native.stack;
		} else {
			let e = null;
			if(Error.captureStackTrace) {
				Error.captureStackTrace(this,haxe_Exception);
				e = this;
			} else {
				e = new Error();
				if(typeof(e.stack) == "undefined") {
					try { throw e; } catch(_) {}
					this.__skipStack++;
				}
			}
			this.stack = e.stack;
		}
		Error.prepareStackTrace = old;
	}
	unwrap() {
		return this.__nativeException;
	}
	toString() {
		return this.get_message();
	}
	__shiftStack() {
		this.__skipStack++;
	}
	get_message() {
		return this.message;
	}
	get_native() {
		return this.__nativeException;
	}
	get_stack() {
		let _g = this.__exceptionStack;
		if(_g == null) {
			let value = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.normalize(this.stack),this.__skipStack);
			this.setProperty("__exceptionStack",value);
			return value;
		} else {
			return _g;
		}
	}
	setProperty(name,value) {
		try {
			Object.defineProperty(this,name,{ value : value});
		} catch( _g ) {
			this[name] = value;
		}
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			e.__skipStack++;
			return e;
		}
	}
}
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
	,__skipStack: null
	,__nativeException: null
	,__previousException: null
	,__properties__: {get_native: "get_native",get_stack: "get_stack",get_message: "get_message"}
});
class haxe_Log {
	static formatOutput(v,infos) {
		let str = Std.string(v);
		if(infos == null) {
			return str;
		}
		let pstr = infos.fileName + ":" + infos.lineNumber;
		if(infos.customParams != null) {
			let _g = 0;
			let _g1 = infos.customParams;
			while(_g < _g1.length) {
				let v = _g1[_g];
				++_g;
				str += ", " + Std.string(v);
			}
		}
		return pstr + ": " + str;
	}
	static trace(v,infos) {
		let str = haxe_Log.formatOutput(v,infos);
		if(typeof(console) != "undefined" && console.log != null) {
			console.log(str);
		}
	}
}
haxe_Log.__name__ = "haxe.Log";
class haxe_NativeStackTrace {
	static saveStack(e) {
		haxe_NativeStackTrace.lastError = e;
	}
	static callStack() {
		let e = new Error("");
		let stack = haxe_NativeStackTrace.tryHaxeStack(e);
		if(typeof(stack) == "undefined") {
			try {
				throw e;
			} catch( _g ) {
			}
			stack = e.stack;
		}
		return haxe_NativeStackTrace.normalize(stack,2);
	}
	static exceptionStack() {
		return haxe_NativeStackTrace.normalize(haxe_NativeStackTrace.tryHaxeStack(haxe_NativeStackTrace.lastError));
	}
	static toHaxe(s,skip) {
		if(skip == null) {
			skip = 0;
		}
		if(s == null) {
			return [];
		} else if(typeof(s) == "string") {
			let stack = s.split("\n");
			if(stack[0] == "Error") {
				stack.shift();
			}
			let m = [];
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let i = _g++;
				if(skip > i) {
					continue;
				}
				let line = stack[i];
				let matched = line.match(/^    at ([A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
				if(matched != null) {
					let path = matched[1].split(".");
					if(path[0] == "$hxClasses") {
						path.shift();
					}
					let meth = path.pop();
					let file = matched[2];
					let line = Std.parseInt(matched[3]);
					let column = Std.parseInt(matched[4]);
					m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line,column));
				} else {
					m.push(haxe_StackItem.Module(StringTools.trim(line)));
				}
			}
			return m;
		} else if(skip > 0 && Array.isArray(s)) {
			return s.slice(skip);
		} else {
			return s;
		}
	}
	static tryHaxeStack(e) {
		if(e == null) {
			return [];
		}
		let oldValue = Error.prepareStackTrace;
		Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
		let stack = e.stack;
		Error.prepareStackTrace = oldValue;
		return stack;
	}
	static prepareHxStackTrace(e,callsites) {
		let stack = [];
		let _g = 0;
		while(_g < callsites.length) {
			let site = callsites[_g];
			++_g;
			if(haxe_NativeStackTrace.wrapCallSite != null) {
				site = haxe_NativeStackTrace.wrapCallSite(site);
			}
			let method = null;
			let fullName = site.getFunctionName();
			if(fullName != null) {
				let idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					let className = fullName.substring(0,idx);
					let methodName = fullName.substring(idx + 1);
					method = haxe_StackItem.Method(className,methodName);
				} else {
					method = haxe_StackItem.Method(null,fullName);
				}
			}
			let fileName = site.getFileName();
			let fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
			if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
				fileName = fileName.substring(fileAddr + 6);
			}
			stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
		}
		return stack;
	}
	static normalize(stack,skipItems) {
		if(skipItems == null) {
			skipItems = 0;
		}
		if(Array.isArray(stack) && skipItems > 0) {
			return stack.slice(skipItems);
		} else if(typeof(stack) == "string") {
			switch(stack.substring(0,6)) {
			case "Error\n":case "Error:":
				++skipItems;
				break;
			default:
			}
			return haxe_NativeStackTrace.skipLines(stack,skipItems);
		} else {
			return stack;
		}
	}
	static skipLines(stack,skip,pos) {
		if(pos == null) {
			pos = 0;
		}
		while(true) if(skip > 0) {
			pos = stack.indexOf("\n",pos);
			if(pos < 0) {
				return "";
			} else {
				skip = --skip;
				pos += 1;
				continue;
			}
		} else {
			return stack.substring(pos);
		}
	}
}
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
class haxe_Timer {
	constructor(time_ms) {
		let me = this;
		this.id = setInterval(function() {
			me.run();
		},time_ms);
	}
	stop() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	run() {
	}
	static delay(f,time_ms) {
		let t = new haxe_Timer(time_ms);
		t.run = function() {
			t.stop();
			f();
		};
		return t;
	}
}
haxe_Timer.__name__ = "haxe.Timer";
Object.assign(haxe_Timer.prototype, {
	__class__: haxe_Timer
	,id: null
});
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
		this.__skipStack++;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
	,value: null
});
var haxe_ds_Either = $hxEnums["haxe.ds.Either"] = { __ename__:"haxe.ds.Either",__constructs__:null
	,Left: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Left",$_.__params__ = ["v"],$_)
	,Right: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Right",$_.__params__ = ["v"],$_)
};
haxe_ds_Either.__constructs__ = [haxe_ds_Either.Left,haxe_ds_Either.Right];
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
	get(key) {
		return this.h[key];
	}
	remove(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	keys() {
		let a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(key | 0);
		return new haxe_iterators_ArrayIterator(a);
	}
}
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_IntMap.prototype, {
	__class__: haxe_ds_IntMap
	,h: null
});
class haxe_ds_List {
	constructor() {
		this.length = 0;
	}
	add(item) {
		let x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	remove(v) {
		let prev = null;
		let l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	iterator() {
		return new haxe_ds__$List_ListIterator(this.h);
	}
}
haxe_ds_List.__name__ = "haxe.ds.List";
Object.assign(haxe_ds_List.prototype, {
	__class__: haxe_ds_List
	,h: null
	,q: null
	,length: null
});
class haxe_ds__$List_ListNode {
	constructor(item,next) {
		this.item = item;
		this.next = next;
	}
}
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
Object.assign(haxe_ds__$List_ListNode.prototype, {
	__class__: haxe_ds__$List_ListNode
	,item: null
	,next: null
});
class haxe_ds__$List_ListIterator {
	constructor(head) {
		this.head = head;
	}
	hasNext() {
		return this.head != null;
	}
	next() {
		let val = this.head.item;
		this.head = this.head.next;
		return val;
	}
}
haxe_ds__$List_ListIterator.__name__ = "haxe.ds._List.ListIterator";
Object.assign(haxe_ds__$List_ListIterator.prototype, {
	__class__: haxe_ds__$List_ListIterator
	,head: null
});
var haxe_ds_Option = $hxEnums["haxe.ds.Option"] = { __ename__:"haxe.ds.Option",__constructs__:null
	,Some: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Option",toString:$estr}; },$_._hx_name="Some",$_.__params__ = ["v"],$_)
	,None: {_hx_name:"None",_hx_index:1,__enum__:"haxe.ds.Option",toString:$estr}
};
haxe_ds_Option.__constructs__ = [haxe_ds_Option.Some,haxe_ds_Option.None];
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	get(key) {
		return this.h[key];
	}
	keys() {
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.h);
	}
}
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
	,h: null
});
class haxe_ds__$StringMap_StringMapKeyIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		return this.keys[this.current++];
	}
}
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
Object.assign(haxe_ds__$StringMap_StringMapKeyIterator.prototype, {
	__class__: haxe_ds__$StringMap_StringMapKeyIterator
	,h: null
	,keys: null
	,length: null
	,current: null
});
class haxe_exceptions_PosException extends haxe_Exception {
	constructor(message,previous,pos) {
		super(message,previous);
		if(pos == null) {
			this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
		} else {
			this.posInfos = pos;
		}
		this.__skipStack++;
	}
	toString() {
		return "" + super.toString() + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
}
haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException";
haxe_exceptions_PosException.__super__ = haxe_Exception;
Object.assign(haxe_exceptions_PosException.prototype, {
	__class__: haxe_exceptions_PosException
	,posInfos: null
});
class haxe_exceptions_NotImplementedException extends haxe_exceptions_PosException {
	constructor(message,previous,pos) {
		if(message == null) {
			message = "Not implemented";
		}
		super(message,previous,pos);
		this.__skipStack++;
	}
}
haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException";
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
Object.assign(haxe_exceptions_NotImplementedException.prototype, {
	__class__: haxe_exceptions_NotImplementedException
});
class haxe_format_JsonParser {
	constructor(str) {
		this.str = str;
		this.pos = 0;
	}
	doParse() {
		let result = this.parseRec();
		let c;
		while(true) {
			c = this.str.charCodeAt(this.pos++);
			if(!(c == c)) {
				break;
			}
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				this.invalidChar();
			}
		}
		return result;
	}
	parseRec() {
		while(true) {
			let c = this.str.charCodeAt(this.pos++);
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			case 34:
				return this.parseString();
			case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
				let c1 = c;
				let start = this.pos - 1;
				let minus = c == 45;
				let digit = !minus;
				let zero = c == 48;
				let point = false;
				let e = false;
				let pm = false;
				let end = false;
				while(true) {
					c1 = this.str.charCodeAt(this.pos++);
					switch(c1) {
					case 43:case 45:
						if(!e || pm) {
							this.invalidNumber(start);
						}
						digit = false;
						pm = true;
						break;
					case 46:
						if(minus || point || e) {
							this.invalidNumber(start);
						}
						digit = false;
						point = true;
						break;
					case 48:
						if(zero && !point) {
							this.invalidNumber(start);
						}
						if(minus) {
							minus = false;
							zero = true;
						}
						digit = true;
						break;
					case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
						if(zero && !point) {
							this.invalidNumber(start);
						}
						if(minus) {
							minus = false;
						}
						digit = true;
						zero = false;
						break;
					case 69:case 101:
						if(minus || zero || e) {
							this.invalidNumber(start);
						}
						digit = false;
						e = true;
						break;
					default:
						if(!digit) {
							this.invalidNumber(start);
						}
						this.pos--;
						end = true;
					}
					if(end) {
						break;
					}
				}
				let f = parseFloat(HxOverrides.substr(this.str,start,this.pos - start));
				if(point) {
					return f;
				} else {
					let i = f | 0;
					if(i == f) {
						return i;
					} else {
						return f;
					}
				}
				break;
			case 91:
				let arr = [];
				let comma = null;
				while(true) {
					let c = this.str.charCodeAt(this.pos++);
					switch(c) {
					case 9:case 10:case 13:case 32:
						break;
					case 44:
						if(comma) {
							comma = false;
						} else {
							this.invalidChar();
						}
						break;
					case 93:
						if(comma == false) {
							this.invalidChar();
						}
						return arr;
					default:
						if(comma) {
							this.invalidChar();
						}
						this.pos--;
						arr.push(this.parseRec());
						comma = true;
					}
				}
				break;
			case 102:
				let save = this.pos;
				if(this.str.charCodeAt(this.pos++) != 97 || this.str.charCodeAt(this.pos++) != 108 || this.str.charCodeAt(this.pos++) != 115 || this.str.charCodeAt(this.pos++) != 101) {
					this.pos = save;
					this.invalidChar();
				}
				return false;
			case 110:
				let save1 = this.pos;
				if(this.str.charCodeAt(this.pos++) != 117 || this.str.charCodeAt(this.pos++) != 108 || this.str.charCodeAt(this.pos++) != 108) {
					this.pos = save1;
					this.invalidChar();
				}
				return null;
			case 116:
				let save2 = this.pos;
				if(this.str.charCodeAt(this.pos++) != 114 || this.str.charCodeAt(this.pos++) != 117 || this.str.charCodeAt(this.pos++) != 101) {
					this.pos = save2;
					this.invalidChar();
				}
				return true;
			case 123:
				let obj = { };
				let field = null;
				let comma1 = null;
				while(true) {
					let c = this.str.charCodeAt(this.pos++);
					switch(c) {
					case 9:case 10:case 13:case 32:
						break;
					case 34:
						if(field != null || comma1) {
							this.invalidChar();
						}
						field = this.parseString();
						break;
					case 44:
						if(comma1) {
							comma1 = false;
						} else {
							this.invalidChar();
						}
						break;
					case 58:
						if(field == null) {
							this.invalidChar();
						}
						obj[field] = this.parseRec();
						field = null;
						comma1 = true;
						break;
					case 125:
						if(field != null || comma1 == false) {
							this.invalidChar();
						}
						return obj;
					default:
						this.invalidChar();
					}
				}
				break;
			default:
				this.invalidChar();
			}
		}
	}
	parseString() {
		let start = this.pos;
		let buf = null;
		let prev = -1;
		while(true) {
			let c = this.str.charCodeAt(this.pos++);
			if(c == 34) {
				break;
			}
			if(c == 92) {
				if(buf == null) {
					buf = new StringBuf();
				}
				let s = this.str;
				let len = this.pos - start - 1;
				buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
				c = this.str.charCodeAt(this.pos++);
				if(c != 117 && prev != -1) {
					buf.b += String.fromCodePoint(65533);
					prev = -1;
				}
				switch(c) {
				case 34:case 47:case 92:
					buf.b += String.fromCodePoint(c);
					break;
				case 98:
					buf.b += String.fromCodePoint(8);
					break;
				case 102:
					buf.b += String.fromCodePoint(12);
					break;
				case 110:
					buf.b += String.fromCodePoint(10);
					break;
				case 114:
					buf.b += String.fromCodePoint(13);
					break;
				case 116:
					buf.b += String.fromCodePoint(9);
					break;
				case 117:
					let uc = Std.parseInt("0x" + HxOverrides.substr(this.str,this.pos,4));
					this.pos += 4;
					if(prev != -1) {
						if(uc < 56320 || uc > 57343) {
							buf.b += String.fromCodePoint(65533);
							prev = -1;
						} else {
							buf.b += String.fromCodePoint(((prev - 55296 << 10) + (uc - 56320) + 65536));
							prev = -1;
						}
					} else if(uc >= 55296 && uc <= 56319) {
						prev = uc;
					} else {
						buf.b += String.fromCodePoint(uc);
					}
					break;
				default:
					throw haxe_Exception.thrown("Invalid escape sequence \\" + String.fromCodePoint(c) + " at position " + (this.pos - 1));
				}
				start = this.pos;
			} else if(c != c) {
				throw haxe_Exception.thrown("Unclosed string");
			}
		}
		if(prev != -1) {
			buf.b += String.fromCodePoint(65533);
			prev = -1;
		}
		if(buf == null) {
			return HxOverrides.substr(this.str,start,this.pos - start - 1);
		} else {
			let s = this.str;
			let len = this.pos - start - 1;
			buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
			return buf.b;
		}
	}
	invalidChar() {
		this.pos--;
		throw haxe_Exception.thrown("Invalid char " + this.str.charCodeAt(this.pos) + " at position " + this.pos);
	}
	invalidNumber(start) {
		throw haxe_Exception.thrown("Invalid number at position " + start + ": " + HxOverrides.substr(this.str,start,this.pos - start));
	}
}
haxe_format_JsonParser.__name__ = "haxe.format.JsonParser";
Object.assign(haxe_format_JsonParser.prototype, {
	__class__: haxe_format_JsonParser
	,str: null
	,pos: null
});
class haxe_format_JsonPrinter {
	constructor(replacer,space) {
		this.replacer = replacer;
		this.indent = space;
		this.pretty = space != null;
		this.nind = 0;
		this.buf = new StringBuf();
	}
	write(k,v) {
		if(this.replacer != null) {
			v = this.replacer(k,v);
		}
		let _g = Type.typeof(v);
		switch(_g._hx_index) {
		case 0:
			this.buf.b += "null";
			break;
		case 1:
			this.buf.b += Std.string(v);
			break;
		case 2:
			let v1 = isFinite(v) ? Std.string(v) : "null";
			this.buf.b += Std.string(v1);
			break;
		case 3:
			this.buf.b += Std.string(v);
			break;
		case 4:
			this.fieldsString(v,Reflect.fields(v));
			break;
		case 5:
			this.buf.b += "\"<fun>\"";
			break;
		case 6:
			let c = _g.c;
			if(c == String) {
				this.quote(v);
			} else if(c == Array) {
				let v1 = v;
				this.buf.b += String.fromCodePoint(91);
				let len = v1.length;
				let last = len - 1;
				let _g = 0;
				let _g1 = len;
				while(_g < _g1) {
					let i = _g++;
					if(i > 0) {
						this.buf.b += String.fromCodePoint(44);
					} else {
						this.nind++;
					}
					if(this.pretty) {
						this.buf.b += String.fromCodePoint(10);
					}
					if(this.pretty) {
						this.buf.b += Std.string(StringTools.lpad("",this.indent,this.nind * this.indent.length));
					}
					this.write(i,v1[i]);
					if(i == last) {
						this.nind--;
						if(this.pretty) {
							this.buf.b += String.fromCodePoint(10);
						}
						if(this.pretty) {
							this.buf.b += Std.string(StringTools.lpad("",this.indent,this.nind * this.indent.length));
						}
					}
				}
				this.buf.b += String.fromCodePoint(93);
			} else if(c == haxe_ds_StringMap) {
				let v1 = v;
				let o = { };
				let h = v1.h;
				let _g_keys = Object.keys(h);
				let _g_length = _g_keys.length;
				let _g_current = 0;
				while(_g_current < _g_length) {
					let k = _g_keys[_g_current++];
					o[k] = v1.h[k];
				}
				let v2 = o;
				this.fieldsString(v2,Reflect.fields(v2));
			} else if(c == Date) {
				let v1 = v;
				this.quote(HxOverrides.dateStr(v1));
			} else {
				this.classString(v);
			}
			break;
		case 7:
			let i = v._hx_index;
			this.buf.b += Std.string(i);
			break;
		case 8:
			this.buf.b += "\"???\"";
			break;
		}
	}
	classString(v) {
		this.fieldsString(v,Type.getInstanceFields(js_Boot.getClass(v)));
	}
	fieldsString(v,fields) {
		this.buf.b += String.fromCodePoint(123);
		let len = fields.length;
		let last = len - 1;
		let first = true;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			let f = fields[i];
			let value = Reflect.field(v,f);
			if(Reflect.isFunction(value)) {
				continue;
			}
			if(first) {
				this.nind++;
				first = false;
			} else {
				this.buf.b += String.fromCodePoint(44);
			}
			if(this.pretty) {
				this.buf.b += String.fromCodePoint(10);
			}
			if(this.pretty) {
				this.buf.b += Std.string(StringTools.lpad("",this.indent,this.nind * this.indent.length));
			}
			this.quote(f);
			this.buf.b += String.fromCodePoint(58);
			if(this.pretty) {
				this.buf.b += String.fromCodePoint(32);
			}
			this.write(f,value);
			if(i == last) {
				this.nind--;
				if(this.pretty) {
					this.buf.b += String.fromCodePoint(10);
				}
				if(this.pretty) {
					this.buf.b += Std.string(StringTools.lpad("",this.indent,this.nind * this.indent.length));
				}
			}
		}
		this.buf.b += String.fromCodePoint(125);
	}
	quote(s) {
		this.buf.b += String.fromCodePoint(34);
		let i = 0;
		let length = s.length;
		while(i < length) {
			let c = s.charCodeAt(i++);
			switch(c) {
			case 8:
				this.buf.b += "\\b";
				break;
			case 9:
				this.buf.b += "\\t";
				break;
			case 10:
				this.buf.b += "\\n";
				break;
			case 12:
				this.buf.b += "\\f";
				break;
			case 13:
				this.buf.b += "\\r";
				break;
			case 34:
				this.buf.b += "\\\"";
				break;
			case 92:
				this.buf.b += "\\\\";
				break;
			default:
				this.buf.b += String.fromCodePoint(c);
			}
		}
		this.buf.b += String.fromCodePoint(34);
	}
	static print(o,replacer,space) {
		let printer = new haxe_format_JsonPrinter(replacer,space);
		printer.write("",o);
		return printer.buf.b;
	}
}
haxe_format_JsonPrinter.__name__ = "haxe.format.JsonPrinter";
Object.assign(haxe_format_JsonPrinter.prototype, {
	__class__: haxe_format_JsonPrinter
	,buf: null
	,replacer: null
	,indent: null
	,pretty: null
	,nind: null
});
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	blit(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	sub(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	getString(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		let s = "";
		let b = this.b;
		let i = pos;
		let max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			while(i < max) {
				let c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					let code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					let c2 = b[i++];
					let code = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else {
					let c2 = b[i++];
					let c3 = b[i++];
					let u = (c & 15) << 18 | (c2 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				let c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	toString() {
		return this.getString(0,this.length);
	}
	static ofString(s,encoding) {
		if(encoding == haxe_io_Encoding.RawNative) {
			let buf = new Uint8Array(s.length << 1);
			let _g = 0;
			let _g1 = s.length;
			while(_g < _g1) {
				let i = _g++;
				let c = s.charCodeAt(i);
				buf[i << 1] = c & 255;
				buf[i << 1 | 1] = c >> 8;
			}
			return new haxe_io_Bytes(buf.buffer);
		}
		let a = [];
		let i = 0;
		while(i < s.length) {
			let c = s.charCodeAt(i++);
			if(55296 <= c && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
			}
			if(c <= 127) {
				a.push(c);
			} else if(c <= 2047) {
				a.push(192 | c >> 6);
				a.push(128 | c & 63);
			} else if(c <= 65535) {
				a.push(224 | c >> 12);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			} else {
				a.push(240 | c >> 18);
				a.push(128 | c >> 12 & 63);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			}
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
}
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
Object.assign(haxe_io_Bytes.prototype, {
	__class__: haxe_io_Bytes
	,length: null
	,b: null
});
class haxe_io_BytesBuffer {
	constructor() {
		this.pos = 0;
		this.size = 0;
	}
	addByte(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	grow(delta) {
		let req = this.pos + delta;
		let nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		let nbuf = new ArrayBuffer(nsize);
		let nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	getBytes() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		let b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
}
haxe_io_BytesBuffer.__name__ = "haxe.io.BytesBuffer";
Object.assign(haxe_io_BytesBuffer.prototype, {
	__class__: haxe_io_BytesBuffer
	,buffer: null
	,view: null
	,u8: null
	,pos: null
	,size: null
});
class haxe_io_BytesInput extends haxe_io_Input {
	constructor(b,pos,len) {
		super();
		if(pos == null) {
			pos = 0;
		}
		if(len == null) {
			len = b.length - pos;
		}
		if(pos < 0 || len < 0 || pos + len > b.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		this.b = b.b;
		this.pos = pos;
		this.len = len;
		this.totlen = len;
	}
	set_position(p) {
		if(p < 0) {
			p = 0;
		} else if(p > this.totlen) {
			p = this.totlen;
		}
		this.len = this.totlen - p;
		return this.pos = p;
	}
	readByte() {
		if(this.len == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	readBytes(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		let b1 = this.b;
		let b2 = buf.b;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
}
haxe_io_BytesInput.__name__ = "haxe.io.BytesInput";
haxe_io_BytesInput.__super__ = haxe_io_Input;
Object.assign(haxe_io_BytesInput.prototype, {
	__class__: haxe_io_BytesInput
	,b: null
	,pos: null
	,len: null
	,totlen: null
	,__properties__: {set_position: "set_position"}
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:"haxe.io.Encoding",__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
class haxe_io_Eof {
	constructor() {
	}
	toString() {
		return "Eof";
	}
}
haxe_io_Eof.__name__ = "haxe.io.Eof";
Object.assign(haxe_io_Eof.prototype, {
	__class__: haxe_io_Eof
});
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:"haxe.io.Error",__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
	,array: null
	,current: null
});
class haxe_rtti_Meta {
	static getMeta(t) {
		return t.__meta__;
	}
	static getFields(t) {
		let meta = haxe_rtti_Meta.getMeta(t);
		if(meta == null || meta.fields == null) {
			return { };
		} else {
			return meta.fields;
		}
	}
}
haxe_rtti_Meta.__name__ = "haxe.rtti.Meta";
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
var js_node_Path = require("path");
class js_node_buffer__$Buffer_Helper {
	static bytesOfBuffer(b) {
		let o = Object.create(haxe_io_Bytes.prototype);
		o.length = b.byteLength;
		o.b = b;
		b.bufferValue = b;
		b.hxBytes = o;
		b.bytes = b;
		return o;
	}
}
js_node_buffer__$Buffer_Helper.__name__ = "js.node.buffer._Buffer.Helper";
var js_node_net_Socket = require("net").Socket;
var js_node_util_Promisify = require("util").promisify;
class sys_FileSystem {
	static exists(path) {
		try {
			js_node_Fs.accessSync(path);
			return true;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return false;
		}
	}
}
sys_FileSystem.__name__ = "sys.FileSystem";
class utest_ITest {
}
utest_ITest.__name__ = "utest.ITest";
utest_ITest.__isInterface__ = true;
class utest_Test {
	constructor() {
	}
	__initializeUtest__() {
		let init = { tests : [], dependencies : [], accessories : { }};
		return init;
	}
}
utest_Test.__name__ = "utest.Test";
utest_Test.__interfaces__ = [utest_ITest];
Object.assign(utest_Test.prototype, {
	__class__: utest_Test
});
class test_BitShiftTest extends utest_Test {
	constructor() {
		super();
	}
	testChild() {
		let child = gmdebug_VariableReference.encode(gmdebug_VariableReferenceVal.Child(10,123922));
		utest_Assert.same(gmdebug_VariableReferenceVal.Child(10,123922),gmdebug_VariableReference.getValue(child),null,null,null,{ fileName : "test/src/test/BitShiftTest.hx", lineNumber : 12, className : "test.BitShiftTest", methodName : "testChild"});
	}
	testframeLocal() {
		let framelocal = gmdebug_VariableReference.encode(gmdebug_VariableReferenceVal.FrameLocal(10,110213,200));
		utest_Assert.same(gmdebug_VariableReferenceVal.FrameLocal(10,110213,200),gmdebug_VariableReference.getValue(framelocal),null,null,null,{ fileName : "test/src/test/BitShiftTest.hx", lineNumber : 17, className : "test.BitShiftTest", methodName : "testframeLocal"});
	}
	testframeID() {
		let frame = gmdebug_FrameID.getValue(1710612736);
		utest_Assert.same({ clientID : 12, actualFrame : 100000000},frame,null,null,null,{ fileName : "test/src/test/BitShiftTest.hx", lineNumber : 23, className : "test.BitShiftTest", methodName : "testframeID"});
	}
	testglobal() {
		let global1 = gmdebug_VariableReference.encode(gmdebug_VariableReferenceVal.Global(10,100000));
		utest_Assert.same(gmdebug_VariableReferenceVal.Global(10,100000),gmdebug_VariableReference.getValue(global1),null,null,null,{ fileName : "test/src/test/BitShiftTest.hx", lineNumber : 28, className : "test.BitShiftTest", methodName : "testglobal"});
	}
	__initializeUtest__() {
		let init = super.__initializeUtest__();
		let _gthis = this;
		init.tests.push({ name : "testglobal", dependencies : [], execute : function() {
			_gthis.testglobal();
			return utest_Async.getResolved();
		}});
		init.tests.push({ name : "testframeLocal", dependencies : [], execute : function() {
			_gthis.testframeLocal();
			return utest_Async.getResolved();
		}});
		init.tests.push({ name : "testframeID", dependencies : [], execute : function() {
			_gthis.testframeID();
			return utest_Async.getResolved();
		}});
		init.tests.push({ name : "testChild", dependencies : [], execute : function() {
			_gthis.testChild();
			return utest_Async.getResolved();
		}});
		return init;
	}
}
test_BitShiftTest.__name__ = "test.BitShiftTest";
test_BitShiftTest.__super__ = utest_Test;
Object.assign(test_BitShiftTest.prototype, {
	__class__: test_BitShiftTest
});
class test_HandlerTests extends utest_Test {
	constructor() {
		super();
	}
	setupClass(async) {
		this.session = new test_LuaDebuggerTest(false);
		let _gthis = this;
		process.on("SIGTRM",function() {
			_gthis.session.shutdown();
		});
		this.session.start(process.stdin,process.stdout);
		haxe_Log.trace = function(v,infos) {
			let str = haxe_Log.formatOutput(v,infos);
			console.error(str);
		};
		let launchArgs = { serverFolder : "/home/g/gmodDS/garrysmod/", programPath : "auto"};
		test_TestHelper.send(new gmdebug_composer_ComposedRequest("launch",launchArgs),this.session);
		this.session.waitForEvent("initialized").handle(function(__t9) {
			let __t9_result;
			let _g = tink_await_OutcomeTools.getOutcome(null,__t9);
			switch(_g._hx_index) {
			case 0:
				let v = _g.data;
				__t9_result = v;
				break;
			case 1:
				let e = _g.failure;
				throw haxe_Exception.thrown(e);
			}
			test_TestHelper.send(new gmdebug_composer_ComposedRequest("configurationDone",{ }),_gthis.session);
			async.done({ fileName : "test/src/test/HandlerTests.hx", lineNumber : 39, className : "test.HandlerTests", methodName : "setupClass"});
		});
	}
	testPause(async) {
		haxe_Log.trace("starting test",{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 44, className : "test.HandlerTests", methodName : "testPause"});
		test_TestHelper.send(new gmdebug_composer_ComposedRequest("pause",{ threadId : 0}),this.session);
		let pause = tink_core_Future.and(this.session.waitForResponse("pause"),this.session.waitForEvent("stopped"));
		let _gthis = this;
		pause.handle(function(__t10) {
			let __t10_result;
			let _g = tink_await_OutcomeTools.getOutcome(null,__t10);
			switch(_g._hx_index) {
			case 0:
				__t10_result = _g.data;
				break;
			case 1:
				throw haxe_Exception.thrown(_g.failure);
			}
			let dothing = __t10_result;
			haxe_Log.trace("found both",{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 48, className : "test.HandlerTests", methodName : "testPause"});
			test_TestHelper.ok(dothing.a);
			test_TestHelper.send(new gmdebug_composer_ComposedRequest("continue",{ threadId : 0}),_gthis.session);
			_gthis.session.waitForResponse("continue").handle(function(__t11) {
				let __t11_result;
				let _g = tink_await_OutcomeTools.getOutcome(null,__t11);
				switch(_g._hx_index) {
				case 0:
					__t11_result = _g.data;
					break;
				case 1:
					throw haxe_Exception.thrown(_g.failure);
				}
				let cont = __t11_result;
				test_TestHelper.ok(cont);
				haxe_Log.trace("continued ok",{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 53, className : "test.HandlerTests", methodName : "testPause"});
				async.done({ fileName : "test/src/test/HandlerTests.hx", lineNumber : 54, className : "test.HandlerTests", methodName : "testPause"});
			});
		});
	}
	sendBreakpoint() {
		test_TestHelper.send(new gmdebug_composer_ComposedRequest("setBreakpoints",{ source : { path : "/home/g/gmodDS/garrysmod/lua/includes/modules/hook.lua"}, breakpoints : [{ line : 84}]}),this.session);
	}
	ridBreakpoint() {
		test_TestHelper.send(new gmdebug_composer_ComposedRequest("setBreakpoints",{ source : { path : "/home/g/gmodDS/garrysmod/lua/includes/modules/hook.lua"}, breakpoints : []}),this.session);
	}
	testBreakpoint(async) {
		this.sendBreakpoint();
		let _gthis = this;
		this.session.waitForResponse("setBreakpoints").handle(function(__t12) {
			let __t12_result;
			let _g = tink_await_OutcomeTools.getOutcome(null,__t12);
			switch(_g._hx_index) {
			case 0:
				__t12_result = _g.data;
				break;
			case 1:
				throw haxe_Exception.thrown(_g.failure);
			}
			let rep = __t12_result;
			test_TestHelper.ok(rep);
			_gthis.session.waitForEvent("stopped").handle(function(__t13) {
				let __t13_result;
				let _g = tink_await_OutcomeTools.getOutcome(null,__t13);
				switch(_g._hx_index) {
				case 0:
					__t13_result = _g.data;
					break;
				case 1:
					throw haxe_Exception.thrown(_g.failure);
				}
				let breakpoint = __t13_result;
				utest_Assert.equals("breakpoint",breakpoint.body.reason,null,{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 79, className : "test.HandlerTests", methodName : "testBreakpoint"});
				_gthis.ridBreakpoint();
				_gthis.session.waitForResponse("setBreakpoints").handle(function(__t14) {
					let _g = tink_await_OutcomeTools.getOutcome(null,__t14);
					switch(_g._hx_index) {
					case 0:
						break;
					case 1:
						throw haxe_Exception.thrown(_g.failure);
					}
					async.done({ fileName : "test/src/test/HandlerTests.hx", lineNumber : 82, className : "test.HandlerTests", methodName : "testBreakpoint"});
				});
			});
		});
	}
	wait(ms) {
		return tink_core_Future.irreversible(function(cb) {
			haxe_Timer.delay(function() {
				cb(null);
			},ms);
		});
	}
	testBreakpointOnOff(async) {
		this.sendBreakpoint();
		let _gthis = this;
		this.session.waitForResponse("setBreakpoints").handle(function(__t15) {
			let __t15_result;
			let _g = tink_await_OutcomeTools.getOutcome(null,__t15);
			switch(_g._hx_index) {
			case 0:
				__t15_result = _g.data;
				break;
			case 1:
				throw haxe_Exception.thrown(_g.failure);
			}
			let rep = __t15_result;
			test_TestHelper.ok(rep);
			_gthis.session.waitForEvent("stopped").handle(function(__t16) {
				let __t16_result;
				let _g = tink_await_OutcomeTools.getOutcome(null,__t16);
				switch(_g._hx_index) {
				case 0:
					__t16_result = _g.data;
					break;
				case 1:
					throw haxe_Exception.thrown(_g.failure);
				}
				let breakpoint = __t16_result;
				utest_Assert.equals("breakpoint",breakpoint.body.reason,null,{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 96, className : "test.HandlerTests", methodName : "testBreakpointOnOff"});
				_gthis.ridBreakpoint();
				_gthis.session.waitForResponse("setBreakpoints").handle(function(__t17) {
					let _g = tink_await_OutcomeTools.getOutcome(null,__t17);
					switch(_g._hx_index) {
					case 0:
						break;
					case 1:
						throw haxe_Exception.thrown(_g.failure);
					}
					test_TestHelper.send(new gmdebug_composer_ComposedRequest("continue",{ threadId : 0}),_gthis.session);
					async.setTimeout(600,{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 102, className : "test.HandlerTests", methodName : "testBreakpointOnOff"});
					let pass = _gthis.wait(500);
					let stoppedAgain = _gthis.session.waitForEvent("stopped");
					let result = tink_core_Future.either(stoppedAgain,pass);
					result.handle(function(val) {
						haxe_Log.trace("dot dot dot",{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 108, className : "test.HandlerTests", methodName : "testBreakpointOnOff"});
						switch(val._hx_index) {
						case 0:
							utest_Assert.fail("Stopped after breakpoint removed",{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 111, className : "test.HandlerTests", methodName : "testBreakpointOnOff"});
							break;
						case 1:
							haxe_Log.trace("pass",{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 113, className : "test.HandlerTests", methodName : "testBreakpointOnOff"});
							utest_Assert.pass(null,{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 114, className : "test.HandlerTests", methodName : "testBreakpointOnOff"});
							break;
						}
						async.done({ fileName : "test/src/test/HandlerTests.hx", lineNumber : 117, className : "test.HandlerTests", methodName : "testBreakpointOnOff"});
					});
				});
			});
		});
	}
	testStackHeight(async) {
		this.sendBreakpoint();
		let _gthis = this;
		this.session.waitForEvent("stopped").handle(function(__t18) {
			let _g = tink_await_OutcomeTools.getOutcome(null,__t18);
			switch(_g._hx_index) {
			case 0:
				break;
			case 1:
				throw haxe_Exception.thrown(_g.failure);
			}
			test_TestHelper.send(new gmdebug_composer_ComposedRequest("stackTrace",{ threadId : 0}),_gthis.session);
			_gthis.session.waitForResponse("stackTrace").handle(function(__t19) {
				let __t19_result;
				let _g = tink_await_OutcomeTools.getOutcome(null,__t19);
				switch(_g._hx_index) {
				case 0:
					__t19_result = _g.data;
					break;
				case 1:
					throw haxe_Exception.thrown(_g.failure);
				}
				let stackRep = __t19_result;
				let stackFrames = stackRep.body.stackFrames;
				utest_Assert.equals(1,stackFrames.length,"Incorrect stack height!!!",{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 131, className : "test.HandlerTests", methodName : "testStackHeight"});
				utest_Assert.equals(84,stackFrames[0].line,null,{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 132, className : "test.HandlerTests", methodName : "testStackHeight"});
				_gthis.ridBreakpoint();
				_gthis.session.waitForResponse("setBreakpoints").handle(function(__t20) {
					let _g = tink_await_OutcomeTools.getOutcome(null,__t20);
					switch(_g._hx_index) {
					case 0:
						break;
					case 1:
						throw haxe_Exception.thrown(_g.failure);
					}
					async.done({ fileName : "test/src/test/HandlerTests.hx", lineNumber : 135, className : "test.HandlerTests", methodName : "testStackHeight"});
				});
			});
		});
	}
	testScopes(async) {
		this.sendBreakpoint();
		let _gthis = this;
		this.session.waitForEvent("stopped").handle(function(__t21) {
			let _g = tink_await_OutcomeTools.getOutcome(null,__t21);
			switch(_g._hx_index) {
			case 0:
				break;
			case 1:
				throw haxe_Exception.thrown(_g.failure);
			}
			test_TestHelper.send(new gmdebug_composer_ComposedRequest("stackTrace",{ threadId : 0}),_gthis.session);
			_gthis.session.waitForResponse("stackTrace").handle(function(__t22) {
				let __t22_result;
				let _g = tink_await_OutcomeTools.getOutcome(null,__t22);
				switch(_g._hx_index) {
				case 0:
					__t22_result = _g.data;
					break;
				case 1:
					throw haxe_Exception.thrown(_g.failure);
				}
				let stackRep = __t22_result;
				let stackFrames = stackRep.body.stackFrames;
				test_TestHelper.send(new gmdebug_composer_ComposedRequest("scopes",{ frameId : stackFrames[0].id}),_gthis.session);
				_gthis.session.waitForResponse("scopes").handle(function(__t23) {
					let __t23_result;
					let _g = tink_await_OutcomeTools.getOutcome(null,__t23);
					switch(_g._hx_index) {
					case 0:
						__t23_result = _g.data;
						break;
					case 1:
						throw haxe_Exception.thrown(_g.failure);
					}
					let scopesRep = __t23_result;
					test_TestHelper.ok(scopesRep);
					utest_Assert.notEquals(0,scopesRep.body.scopes.length,null,{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 149, className : "test.HandlerTests", methodName : "testScopes"});
					_gthis.ridBreakpoint();
					_gthis.session.waitForResponse("setBreakpoints").handle(function(__t24) {
						let _g = tink_await_OutcomeTools.getOutcome(null,__t24);
						switch(_g._hx_index) {
						case 0:
							break;
						case 1:
							throw haxe_Exception.thrown(_g.failure);
						}
						async.done({ fileName : "test/src/test/HandlerTests.hx", lineNumber : 152, className : "test.HandlerTests", methodName : "testScopes"});
					});
				});
			});
		});
	}
	testArgs(async) {
		this.sendBreakpoint();
		let _gthis = this;
		this.session.waitForEvent("stopped").handle(function(__t25) {
			let _g = tink_await_OutcomeTools.getOutcome(null,__t25);
			switch(_g._hx_index) {
			case 0:
				break;
			case 1:
				throw haxe_Exception.thrown(_g.failure);
			}
			test_TestHelper.send(new gmdebug_composer_ComposedRequest("stackTrace",{ threadId : 0}),_gthis.session);
			_gthis.session.waitForResponse("stackTrace").handle(function(__t26) {
				let __t26_result;
				let _g = tink_await_OutcomeTools.getOutcome(null,__t26);
				switch(_g._hx_index) {
				case 0:
					__t26_result = _g.data;
					break;
				case 1:
					throw haxe_Exception.thrown(_g.failure);
				}
				let stackRep = __t26_result;
				let stackFrames = stackRep.body.stackFrames;
				test_TestHelper.send(new gmdebug_composer_ComposedRequest("scopes",{ frameId : stackFrames[0].id}),_gthis.session);
				_gthis.session.waitForResponse("scopes").handle(function(__t27) {
					let __t27_result;
					let _g = tink_await_OutcomeTools.getOutcome(null,__t27);
					switch(_g._hx_index) {
					case 0:
						__t27_result = _g.data;
						break;
					case 1:
						throw haxe_Exception.thrown(_g.failure);
					}
					let scopesRep = __t27_result;
					utest_Assert.isTrue(Lambda.exists(scopesRep.body.scopes,function(scope) {
						return scope.name == "Arguments";
					}),"No arguments scope...",{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 165, className : "test.HandlerTests", methodName : "testArgs"});
					test_TestHelper.send(new gmdebug_composer_ComposedRequest("variables",{ variablesReference : gmdebug_VariableReference.encode(gmdebug_VariableReferenceVal.FrameLocal(0,stackFrames[0].id,0))}),_gthis.session);
					_gthis.session.waitForResponse("variables").handle(function(__t28) {
						let __t28_result;
						let _g = tink_await_OutcomeTools.getOutcome(null,__t28);
						switch(_g._hx_index) {
						case 0:
							__t28_result = _g.data;
							break;
						case 1:
							throw haxe_Exception.thrown(_g.failure);
						}
						let variablesRep = __t28_result;
						test_TestHelper.ok(variablesRep);
						let variablesArr = variablesRep.body.variables;
						utest_Assert.equals(2,variablesArr.length,null,{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 172, className : "test.HandlerTests", methodName : "testArgs"});
						utest_Assert.equals("name",variablesArr[0].name,null,{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 173, className : "test.HandlerTests", methodName : "testArgs"});
						utest_Assert.equals("gm",variablesArr[1].name,null,{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 174, className : "test.HandlerTests", methodName : "testArgs"});
						_gthis.ridBreakpoint();
						_gthis.session.waitForResponse("setBreakpoints").handle(function(__t29) {
							let _g = tink_await_OutcomeTools.getOutcome(null,__t29);
							switch(_g._hx_index) {
							case 0:
								break;
							case 1:
								throw haxe_Exception.thrown(_g.failure);
							}
							async.done({ fileName : "test/src/test/HandlerTests.hx", lineNumber : 177, className : "test.HandlerTests", methodName : "testArgs"});
						});
					});
				});
			});
		});
	}
	testSteps() {
		this.sendBreakpoint();
		let _gthis = this;
		this.session.waitForEvent("stopped").handle(function(__t30) {
			let _g = tink_await_OutcomeTools.getOutcome(null,__t30);
			switch(_g._hx_index) {
			case 0:
				break;
			case 1:
				throw haxe_Exception.thrown(_g.failure);
			}
			test_TestHelper.send(new gmdebug_composer_ComposedRequest("stackTrace",{ threadId : 0}),_gthis.session);
			_gthis.session.waitForResponse("stackTrace").handle(function(__t31) {
				let _g = tink_await_OutcomeTools.getOutcome(null,__t31);
				switch(_g._hx_index) {
				case 0:
					break;
				case 1:
					throw haxe_Exception.thrown(_g.failure);
				}
				test_TestHelper.send(new gmdebug_composer_ComposedRequest("stepIn",{ threadId : 0}),_gthis.session);
				_gthis.session.waitForEvent("stopped").handle(function(__t32) {
					let _g = tink_await_OutcomeTools.getOutcome(null,__t32);
					switch(_g._hx_index) {
					case 0:
						break;
					case 1:
						throw haxe_Exception.thrown(_g.failure);
					}
				});
			});
		});
	}
	teardown(async) {
		this.session.clearHandlers();
		haxe_Log.trace("tearing down...",{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 195, className : "test.HandlerTests", methodName : "teardown"});
		test_TestHelper.send(new gmdebug_composer_ComposedRequest("continue",{ threadId : 0}),this.session);
		let _gthis = this;
		this.session.waitForResponse("continue").handle(function(__t33) {
			let __t33_result;
			let _g = tink_await_OutcomeTools.getOutcome(null,__t33);
			switch(_g._hx_index) {
			case 0:
				__t33_result = _g.data;
				break;
			case 1:
				throw haxe_Exception.thrown(_g.failure);
			}
			let contRep = __t33_result;
			test_TestHelper.ok(contRep);
			haxe_Log.trace("tore down",{ fileName : "test/src/test/HandlerTests.hx", lineNumber : 199, className : "test.HandlerTests", methodName : "teardown"});
			_gthis.session.clearHandlers();
			async.done({ fileName : "test/src/test/HandlerTests.hx", lineNumber : 201, className : "test.HandlerTests", methodName : "teardown"});
		});
	}
	teardownClass() {
		test_TestHelper.send(new gmdebug_composer_ComposedRequest("disconnect",{ }),this.session);
	}
	__initializeUtest__() {
		let init = super.__initializeUtest__();
		let _gthis = this;
		init.accessories.setupClass = function() {
			let async = new utest_Async(10000);
			_gthis.setupClass(async);
			return async;
		};
		init.accessories.teardown = function() {
			let async = new utest_Async(2000);
			_gthis.teardown(async);
			return async;
		};
		init.accessories.teardownClass = function() {
			_gthis.teardownClass();
			return utest_Async.getResolved();
		};
		init.tests.push({ name : "testBreakpoint", dependencies : [], execute : function() {
			let async = new utest_Async(2000);
			_gthis.testBreakpoint(async);
			return async;
		}});
		init.tests.push({ name : "testStackHeight", dependencies : ["testBreakpoint"], execute : function() {
			let async = new utest_Async(1000);
			_gthis.testStackHeight(async);
			return async;
		}});
		init.tests.push({ name : "testScopes", dependencies : ["testStackHeight"], execute : function() {
			let async = new utest_Async(1000);
			_gthis.testScopes(async);
			return async;
		}});
		init.tests.push({ name : "testSteps", dependencies : ["testScopes"], execute : function() {
			_gthis.testSteps();
			return utest_Async.getResolved();
		}});
		init.tests.push({ name : "testPause", dependencies : [], execute : function() {
			let async = new utest_Async(1000);
			_gthis.testPause(async);
			return async;
		}});
		init.tests.push({ name : "testBreakpointOnOff", dependencies : ["testBreakpoint"], execute : function() {
			let async = new utest_Async(2500);
			_gthis.testBreakpointOnOff(async);
			return async;
		}});
		init.tests.push({ name : "testArgs", dependencies : ["testStackHeight"], execute : function() {
			let async = new utest_Async(1000);
			_gthis.testArgs(async);
			return async;
		}});
		return init;
	}
}
test_HandlerTests.__name__ = "test.HandlerTests";
test_HandlerTests.__super__ = utest_Test;
Object.assign(test_HandlerTests.prototype, {
	__class__: test_HandlerTests
	,session: null
});
class test_LuaDebuggerTest extends gmdebug_dap_LuaDebugger {
	constructor(x,y) {
		super(x,y);
		this.eventEvents = new haxe_ds_StringMap();
		this.responseEvents = new haxe_ds_StringMap();
	}
	handleMessage(message) {
		super.handleMessage(message);
	}
	clearHandlers() {
		this.eventEvents = new haxe_ds_StringMap();
		this.responseEvents = new haxe_ds_StringMap();
	}
	sendResponse(response) {
		let responseName = response.command;
		let handlers = this.responseEvents.h[responseName];
		if(handlers != null) {
			haxe_Log.trace("bye " + responseName,{ fileName : "test/src/test/LuaDebuggerTest.hx", lineNumber : 42, className : "test.LuaDebuggerTest", methodName : "sendResponse"});
			let _this = this.responseEvents;
			if(Object.prototype.hasOwnProperty.call(_this.h,responseName)) {
				delete(_this.h[responseName]);
			}
			Lambda.iter(handlers,function(fun) {
				fun(response);
			});
		}
	}
	sendEvent(event) {
		let eventName = event.event;
		let handlers = this.eventEvents.h[eventName];
		if(Object.prototype.hasOwnProperty.call(this.eventEvents.h,eventName)) {
			let _this = this.eventEvents;
			if(Object.prototype.hasOwnProperty.call(_this.h,eventName)) {
				delete(_this.h[eventName]);
			}
			Lambda.iter(handlers,function(fun) {
				fun(event);
			});
		}
	}
	shutdown() {
		let _g = this.dapMode;
		if(_g._hx_index == 1) {
			let _g1 = _g.child;
			_g1.write("quit\n");
			_g1.kill();
		}
		this.clients.disconnectAll();
	}
	_waitForEvent(message,listener) {
		let arr = this.eventEvents.h[message];
		if(arr != null) {
			arr.push(listener);
		} else {
			this.eventEvents.h[message] = [listener];
		}
	}
	_waitForResponse(message,listener) {
		let arr = this.responseEvents.h[message];
		if(arr != null) {
			arr.push(listener);
		} else {
			this.responseEvents.h[message] = [listener];
		}
	}
	waitForEvent(message) {
		let _g = $bind(this,this._waitForEvent);
		let message1 = message;
		return tink_core_Future.irreversible(function(listener) {
			_g(message1,listener);
		});
	}
	waitForResponse(message) {
		let _g = $bind(this,this._waitForResponse);
		let message1 = message;
		return tink_core_Future.irreversible(function(listener) {
			_g(message1,listener);
		});
	}
}
test_LuaDebuggerTest.__name__ = "test.LuaDebuggerTest";
test_LuaDebuggerTest.__super__ = gmdebug_dap_LuaDebugger;
Object.assign(test_LuaDebuggerTest.prototype, {
	__class__: test_LuaDebuggerTest
	,eventEvents: null
	,responseEvents: null
});
class test_Main {
	static main() {
		utest_UTest.run([new test_BitShiftTest(),new test_HandlerTests()]);
	}
}
test_Main.__name__ = "test.Main";
class test_TestHelper {
	static ok(x) {
		utest_Assert.isTrue(x.success,null,{ fileName : "test/src/test/TestHelper.hx", lineNumber : 12, className : "test.TestHelper", methodName : "ok"});
	}
	static send(x,luaDebug) {
		luaDebug.handleMessage(x);
	}
}
test_TestHelper.__name__ = "test.TestHelper";
class tink_await_Error {
	static fromAny(any) {
		if(((any) instanceof tink_core_TypedError)) {
			return any;
		} else {
			return tink_core_TypedError.withData(0,"Unexpected Error",any,{ fileName : "tink/await/Error.hx", lineNumber : 12, className : "tink.await._Error.Error_Impl_", methodName : "fromAny"});
		}
	}
}
class tink_await_OutcomeTools {
	static getOutcome(outcome,value) {
		if(outcome == null) {
			return tink_core_Outcome.Success(value);
		} else {
			switch(outcome._hx_index) {
			case 0:
				return outcome;
			case 1:
				let _g = outcome.failure;
				if(((_g) instanceof tink_core_TypedError)) {
					return outcome;
				} else {
					return tink_core_Outcome.Failure(tink_await_Error.fromAny(_g));
				}
				break;
			}
		}
	}
}
tink_await_OutcomeTools.__name__ = "tink.await.OutcomeTools";
class tink_core_Callback {
	static invoke(this1,data) {
		if(tink_core_Callback.depth < 500) {
			tink_core_Callback.depth++;
			this1(data);
			tink_core_Callback.depth--;
		} else {
			tink_core_Callback.defer(function() {
				this1(data);
			});
		}
	}
	static defer(f) {
		process.nextTick(f);
	}
}
class tink_core_LinkObject {
}
tink_core_LinkObject.__name__ = "tink.core.LinkObject";
tink_core_LinkObject.__isInterface__ = true;
Object.assign(tink_core_LinkObject.prototype, {
	__class__: tink_core_LinkObject
	,cancel: null
});
class tink_core__$Callback_LinkPair {
	constructor(a,b) {
		this.dissolved = false;
		this.a = a;
		this.b = b;
	}
	cancel() {
		if(!this.dissolved) {
			this.dissolved = true;
			let this1 = this.a;
			if(this1 != null) {
				this1.cancel();
			}
			let this2 = this.b;
			if(this2 != null) {
				this2.cancel();
			}
			this.a = null;
			this.b = null;
		}
	}
}
tink_core__$Callback_LinkPair.__name__ = "tink.core._Callback.LinkPair";
tink_core__$Callback_LinkPair.__interfaces__ = [tink_core_LinkObject];
Object.assign(tink_core__$Callback_LinkPair.prototype, {
	__class__: tink_core__$Callback_LinkPair
	,a: null
	,b: null
	,dissolved: null
});
class tink_core__$Callback_ListCell {
	constructor(cb,list) {
		if(cb == null) {
			throw haxe_Exception.thrown("callback expected but null received");
		}
		this.cb = cb;
		this.list = list;
	}
	cancel() {
		if(this.list != null) {
			let list = this.list;
			this.cb = null;
			this.list = null;
			if(--list.used <= list.cells.length >> 1) {
				list.compact();
			}
		}
	}
}
tink_core__$Callback_ListCell.__name__ = "tink.core._Callback.ListCell";
tink_core__$Callback_ListCell.__interfaces__ = [tink_core_LinkObject];
Object.assign(tink_core__$Callback_ListCell.prototype, {
	__class__: tink_core__$Callback_ListCell
	,cb: null
	,list: null
});
class tink_core_Disposable {
}
tink_core_Disposable.__name__ = "tink.core.Disposable";
tink_core_Disposable.__isInterface__ = true;
class tink_core_OwnedDisposable {
}
tink_core_OwnedDisposable.__name__ = "tink.core.OwnedDisposable";
tink_core_OwnedDisposable.__isInterface__ = true;
tink_core_OwnedDisposable.__interfaces__ = [tink_core_Disposable];
class tink_core_SimpleDisposable {
	constructor(dispose) {
		if(tink_core_SimpleDisposable._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(dispose);
	}
	_hx_constructor(dispose) {
		this.disposeHandlers = [];
		this.f = dispose;
	}
	dispose() {
		let _g = this.disposeHandlers;
		if(_g != null) {
			this.disposeHandlers = null;
			let f = this.f;
			this.f = tink_core_SimpleDisposable.noop;
			f();
			let _g1 = 0;
			while(_g1 < _g.length) {
				let h = _g[_g1];
				++_g1;
				h();
			}
		}
	}
	static noop() {
	}
}
tink_core_SimpleDisposable.__name__ = "tink.core.SimpleDisposable";
tink_core_SimpleDisposable.__interfaces__ = [tink_core_OwnedDisposable];
Object.assign(tink_core_SimpleDisposable.prototype, {
	__class__: tink_core_SimpleDisposable
	,f: null
	,disposeHandlers: null
});
class tink_core_CallbackList extends tink_core_SimpleDisposable {
	constructor(destructive) {
		tink_core_SimpleDisposable._hx_skip_constructor = true;
		super();
		tink_core_SimpleDisposable._hx_skip_constructor = false;
		this._hx_constructor(destructive);
	}
	_hx_constructor(destructive) {
		if(destructive == null) {
			destructive = false;
		}
		this.onfill = function() {
		};
		this.ondrain = function() {
		};
		this.busy = false;
		this.queue = [];
		this.used = 0;
		let _gthis = this;
		super._hx_constructor(function() {
			if(!_gthis.busy) {
				_gthis.destroy();
			}
		});
		this.destructive = destructive;
		this.cells = [];
	}
	destroy() {
		let _g = 0;
		let _g1 = this.cells;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.cb = null;
			c.list = null;
		}
		this.queue = null;
		this.cells = null;
		if(this.used > 0) {
			this.used = 0;
			let fn = this.ondrain;
			if(tink_core_Callback.depth < 500) {
				tink_core_Callback.depth++;
				fn();
				tink_core_Callback.depth--;
			} else {
				tink_core_Callback.defer(fn);
			}
		}
	}
	invoke(data) {
		let _gthis = this;
		if(tink_core_Callback.depth < 500) {
			tink_core_Callback.depth++;
			if(_gthis.disposeHandlers != null) {
				if(_gthis.busy) {
					if(_gthis.destructive != true) {
						let _g = $bind(_gthis,_gthis.invoke);
						let data1 = data;
						let tmp = function() {
							_g(data1);
						};
						_gthis.queue.push(tmp);
					}
				} else {
					_gthis.busy = true;
					if(_gthis.destructive) {
						_gthis.dispose();
					}
					let length = _gthis.cells.length;
					let _g = 0;
					while(_g < length) {
						let i = _g++;
						let _this = _gthis.cells[i];
						if(_this.list != null) {
							_this.cb(data);
						}
					}
					_gthis.busy = false;
					if(_gthis.disposeHandlers == null) {
						_gthis.destroy();
					} else {
						if(_gthis.used < _gthis.cells.length) {
							_gthis.compact();
						}
						if(_gthis.queue.length > 0) {
							(_gthis.queue.shift())();
						}
					}
				}
			}
			tink_core_Callback.depth--;
		} else {
			tink_core_Callback.defer(function() {
				if(_gthis.disposeHandlers != null) {
					if(_gthis.busy) {
						if(_gthis.destructive != true) {
							let _g = $bind(_gthis,_gthis.invoke);
							let data1 = data;
							let tmp = function() {
								_g(data1);
							};
							_gthis.queue.push(tmp);
						}
					} else {
						_gthis.busy = true;
						if(_gthis.destructive) {
							_gthis.dispose();
						}
						let length = _gthis.cells.length;
						let _g = 0;
						while(_g < length) {
							let i = _g++;
							let _this = _gthis.cells[i];
							if(_this.list != null) {
								_this.cb(data);
							}
						}
						_gthis.busy = false;
						if(_gthis.disposeHandlers == null) {
							_gthis.destroy();
						} else {
							if(_gthis.used < _gthis.cells.length) {
								_gthis.compact();
							}
							if(_gthis.queue.length > 0) {
								(_gthis.queue.shift())();
							}
						}
					}
				}
			});
		}
	}
	compact() {
		if(this.busy) {
			return;
		} else if(this.used == 0) {
			this.resize(0);
			let fn = this.ondrain;
			if(tink_core_Callback.depth < 500) {
				tink_core_Callback.depth++;
				fn();
				tink_core_Callback.depth--;
			} else {
				tink_core_Callback.defer(fn);
			}
		} else {
			let compacted = 0;
			let _g = 0;
			let _g1 = this.cells.length;
			while(_g < _g1) {
				let i = _g++;
				let _g1 = this.cells[i];
				if(_g1.cb != null) {
					if(compacted != i) {
						this.cells[compacted] = _g1;
					}
					if(++compacted == this.used) {
						break;
					}
				}
			}
			this.resize(this.used);
		}
	}
	resize(length) {
		this.cells.length = length;
	}
}
tink_core_CallbackList.__name__ = "tink.core.CallbackList";
tink_core_CallbackList.__super__ = tink_core_SimpleDisposable;
Object.assign(tink_core_CallbackList.prototype, {
	__class__: tink_core_CallbackList
	,destructive: null
	,cells: null
	,used: null
	,queue: null
	,busy: null
	,ondrain: null
	,onfill: null
});
class tink_core_TypedError {
	constructor(code,message,pos) {
		if(code == null) {
			code = 500;
		}
		this.isTinkError = true;
		this.code = code;
		this.message = message;
		this.pos = pos;
		this.exceptionStack = [];
		this.callStack = [];
	}
	printPos() {
		return this.pos.className + "." + this.pos.methodName + ":" + this.pos.lineNumber;
	}
	toString() {
		let ret = "Error#" + this.code + ": " + this.message;
		if(this.pos != null) {
			ret += " @ " + this.printPos();
		}
		return ret;
	}
	static withData(code,message,data,pos) {
		return tink_core_TypedError.typed(code,message,data,pos);
	}
	static typed(code,message,data,pos) {
		let ret = new tink_core_TypedError(code,message,pos);
		ret.data = data;
		return ret;
	}
	static asError(v) {
		if(v != null && v.isTinkError) {
			return v;
		} else {
			return null;
		}
	}
}
tink_core_TypedError.__name__ = "tink.core.TypedError";
Object.assign(tink_core_TypedError.prototype, {
	__class__: tink_core_TypedError
	,message: null
	,code: null
	,data: null
	,pos: null
	,callStack: null
	,exceptionStack: null
	,isTinkError: null
});
class tink_core__$Future_FutureObject {
}
tink_core__$Future_FutureObject.__name__ = "tink.core._Future.FutureObject";
tink_core__$Future_FutureObject.__isInterface__ = true;
Object.assign(tink_core__$Future_FutureObject.prototype, {
	__class__: tink_core__$Future_FutureObject
	,getStatus: null
	,handle: null
	,eager: null
});
class tink_core__$Future_NeverFuture {
	constructor() {
	}
	getStatus() {
		return tink_core_FutureStatus.NeverEver;
	}
	handle(callback) {
		return null;
	}
	eager() {
	}
}
tink_core__$Future_NeverFuture.__name__ = "tink.core._Future.NeverFuture";
tink_core__$Future_NeverFuture.__interfaces__ = [tink_core__$Future_FutureObject];
Object.assign(tink_core__$Future_NeverFuture.prototype, {
	__class__: tink_core__$Future_NeverFuture
});
class tink_core__$Lazy_Computable {
}
tink_core__$Lazy_Computable.__name__ = "tink.core._Lazy.Computable";
tink_core__$Lazy_Computable.__isInterface__ = true;
Object.assign(tink_core__$Lazy_Computable.prototype, {
	__class__: tink_core__$Lazy_Computable
	,isComputed: null
	,compute: null
	,underlying: null
});
class tink_core__$Lazy_LazyObject {
}
tink_core__$Lazy_LazyObject.__name__ = "tink.core._Lazy.LazyObject";
tink_core__$Lazy_LazyObject.__isInterface__ = true;
tink_core__$Lazy_LazyObject.__interfaces__ = [tink_core__$Lazy_Computable];
Object.assign(tink_core__$Lazy_LazyObject.prototype, {
	__class__: tink_core__$Lazy_LazyObject
	,get: null
});
class tink_core__$Lazy_LazyConst {
	constructor(value) {
		this.value = value;
	}
	isComputed() {
		return true;
	}
	get() {
		return this.value;
	}
	compute() {
	}
	underlying() {
		return null;
	}
}
tink_core__$Lazy_LazyConst.__name__ = "tink.core._Lazy.LazyConst";
tink_core__$Lazy_LazyConst.__interfaces__ = [tink_core__$Lazy_LazyObject];
Object.assign(tink_core__$Lazy_LazyConst.prototype, {
	__class__: tink_core__$Lazy_LazyConst
	,value: null
});
class tink_core__$Future_SyncFuture {
	constructor(value) {
		this.value = value;
	}
	getStatus() {
		return tink_core_FutureStatus.Ready(this.value);
	}
	handle(cb) {
		tink_core_Callback.invoke(cb,tink_core_Lazy.get(this.value));
		return null;
	}
	eager() {
		if(!this.value.isComputed()) {
			tink_core_Lazy.get(this.value);
		}
	}
}
tink_core__$Future_SyncFuture.__name__ = "tink.core._Future.SyncFuture";
tink_core__$Future_SyncFuture.__interfaces__ = [tink_core__$Future_FutureObject];
Object.assign(tink_core__$Future_SyncFuture.prototype, {
	__class__: tink_core__$Future_SyncFuture
	,value: null
});
class tink_core_Future {
	static first(this1,that) {
		let _g = this1;
		switch(_g.getStatus()._hx_index) {
		case 3:
			switch(that.getStatus()._hx_index) {
			case 3:
				return _g;
			case 4:
				return _g;
			default:
				return _g;
			}
			break;
		case 4:
			let v = that;
			return v;
		default:
			switch(that.getStatus()._hx_index) {
			case 3:
				let v1 = that;
				return v1;
			case 4:
				return _g;
			default:
				return new tink_core__$Future_SuspendableFuture(function(fire) {
					return new tink_core__$Callback_LinkPair(this1.handle(fire),that.handle(fire));
				});
			}
		}
	}
	static map(this1,f,gather) {
		let _g = this1.getStatus();
		switch(_g._hx_index) {
		case 3:
			let this2 = _g.result;
			let f1 = f;
			return new tink_core__$Future_SyncFuture(new tink_core__$Lazy_LazyFunc(function() {
				return f1(this2.get());
			},this2));
		case 4:
			return tink_core_Future.NEVER;
		default:
			return new tink_core__$Future_SuspendableFuture(function(fire) {
				return this1.handle(function(v) {
					fire(f(v));
				});
			});
		}
	}
	static merge(this1,that,combine) {
		let _g = this1.getStatus();
		let _g1 = that.getStatus();
		if(_g._hx_index == 4) {
			return tink_core_Future.NEVER;
		} else if(_g1._hx_index == 4) {
			return tink_core_Future.NEVER;
		} else {
			return new tink_core__$Future_SuspendableFuture(function($yield) {
				let check = function(v) {
					let _g = this1.getStatus();
					let _g1 = that.getStatus();
					if(_g._hx_index == 3) {
						if(_g1._hx_index == 3) {
							$yield(combine(tink_core_Lazy.get(_g.result),tink_core_Lazy.get(_g1.result)));
						}
					}
				};
				return new tink_core__$Callback_LinkPair(this1.handle(check),that.handle(check));
			});
		}
	}
	static ofJsPromise(promise) {
		return tink_core_Future.irreversible(function(cb) {
			promise.then(function(a) {
				let _g = cb;
				let a1 = tink_core_Outcome.Success(a);
				tink_core_Callback.defer(function() {
					_g(a1);
				});
			},function(e) {
				cb(tink_core_Outcome.Failure(tink_core_TypedError.withData(null,e.message,e,{ fileName : "tink/core/Future.hx", lineNumber : 156, className : "tink.core._Future.Future_Impl_", methodName : "ofJsPromise"})));
			});
		});
	}
	static irreversible(init) {
		return new tink_core__$Future_SuspendableFuture(function($yield) {
			init($yield);
			return null;
		});
	}
	static either(a,b) {
		return tink_core_Future.first(tink_core_Future.map(a,haxe_ds_Either.Left),tink_core_Future.map(b,haxe_ds_Either.Right));
	}
	static and(a,b) {
		return tink_core_Future.merge(a,b,function(a,b) {
			let this1 = new tink_core_MPair(a,b);
			return this1;
		});
	}
}
var tink_core_FutureStatus = $hxEnums["tink.core.FutureStatus"] = { __ename__:"tink.core.FutureStatus",__constructs__:null
	,Suspended: {_hx_name:"Suspended",_hx_index:0,__enum__:"tink.core.FutureStatus",toString:$estr}
	,Awaited: {_hx_name:"Awaited",_hx_index:1,__enum__:"tink.core.FutureStatus",toString:$estr}
	,EagerlyAwaited: {_hx_name:"EagerlyAwaited",_hx_index:2,__enum__:"tink.core.FutureStatus",toString:$estr}
	,Ready: ($_=function(result) { return {_hx_index:3,result:result,__enum__:"tink.core.FutureStatus",toString:$estr}; },$_._hx_name="Ready",$_.__params__ = ["result"],$_)
	,NeverEver: {_hx_name:"NeverEver",_hx_index:4,__enum__:"tink.core.FutureStatus",toString:$estr}
};
tink_core_FutureStatus.__constructs__ = [tink_core_FutureStatus.Suspended,tink_core_FutureStatus.Awaited,tink_core_FutureStatus.EagerlyAwaited,tink_core_FutureStatus.Ready,tink_core_FutureStatus.NeverEver];
class tink_core__$Future_SuspendableFuture {
	constructor(wakeup) {
		this.status = tink_core_FutureStatus.Suspended;
		let _gthis = this;
		this.wakeup = wakeup;
		this.callbacks = new tink_core_CallbackList(true);
		this.callbacks.ondrain = function() {
			if(_gthis.status == tink_core_FutureStatus.Awaited) {
				_gthis.status = tink_core_FutureStatus.Suspended;
				let this1 = _gthis.link;
				if(this1 != null) {
					this1.cancel();
				}
				_gthis.link = null;
			}
		};
		this.callbacks.onfill = function() {
			if(_gthis.status == tink_core_FutureStatus.Suspended) {
				_gthis.status = tink_core_FutureStatus.Awaited;
				_gthis.arm();
			}
		};
	}
	getStatus() {
		return this.status;
	}
	trigger(value) {
		if(this.status._hx_index != 3) {
			this.status = tink_core_FutureStatus.Ready(new tink_core__$Lazy_LazyConst(value));
			let link = this.link;
			this.link = null;
			this.wakeup = null;
			this.callbacks.invoke(value);
			if(link != null) {
				link.cancel();
			}
		}
	}
	handle(callback) {
		let _g = this.status;
		if(_g._hx_index == 3) {
			tink_core_Callback.invoke(callback,tink_core_Lazy.get(_g.result));
			return null;
		} else {
			let _this = this.callbacks;
			if(_this.disposeHandlers == null) {
				return null;
			} else {
				let node = new tink_core__$Callback_ListCell(callback,_this);
				_this.cells.push(node);
				if(_this.used++ == 0) {
					let fn = _this.onfill;
					if(tink_core_Callback.depth < 500) {
						tink_core_Callback.depth++;
						fn();
						tink_core_Callback.depth--;
					} else {
						tink_core_Callback.defer(fn);
					}
				}
				return node;
			}
		}
	}
	arm() {
		let _gthis = this;
		this.link = this.wakeup(function(x) {
			_gthis.trigger(x);
		});
	}
	eager() {
		switch(this.status._hx_index) {
		case 0:
			this.status = tink_core_FutureStatus.EagerlyAwaited;
			this.arm();
			break;
		case 1:
			this.status = tink_core_FutureStatus.EagerlyAwaited;
			break;
		default:
		}
	}
}
tink_core__$Future_SuspendableFuture.__name__ = "tink.core._Future.SuspendableFuture";
tink_core__$Future_SuspendableFuture.__interfaces__ = [tink_core__$Future_FutureObject];
Object.assign(tink_core__$Future_SuspendableFuture.prototype, {
	__class__: tink_core__$Future_SuspendableFuture
	,callbacks: null
	,status: null
	,link: null
	,wakeup: null
});
class tink_core_Lazy {
	static get(this1) {
		this1.compute();
		return this1.get();
	}
}
class tink_core__$Lazy_LazyFunc {
	constructor(f,from) {
		this.busy = false;
		this.f = f;
		this.from = from;
	}
	underlying() {
		return this.from;
	}
	isComputed() {
		return this.f == null;
	}
	get() {
		return this.result;
	}
	compute() {
		if(this.busy) {
			throw haxe_Exception.thrown(new tink_core_TypedError(null,"circular lazyness",{ fileName : "tink/core/Lazy.hx", lineNumber : 85, className : "tink.core._Lazy.LazyFunc", methodName : "compute"}));
		}
		let _g = this.f;
		if(_g != null) {
			this.busy = true;
			this.f = null;
			let _g1 = this.from;
			if(_g1 != null) {
				let cur = _g1;
				this.from = null;
				let stack = [];
				while(cur != null && !cur.isComputed()) {
					stack.push(cur);
					cur = cur.underlying();
				}
				stack.reverse();
				let _g = 0;
				while(_g < stack.length) {
					let c = stack[_g];
					++_g;
					c.compute();
				}
			}
			this.result = _g();
			this.busy = false;
		}
	}
}
tink_core__$Lazy_LazyFunc.__name__ = "tink.core._Lazy.LazyFunc";
tink_core__$Lazy_LazyFunc.__interfaces__ = [tink_core__$Lazy_LazyObject];
Object.assign(tink_core__$Lazy_LazyFunc.prototype, {
	__class__: tink_core__$Lazy_LazyFunc
	,f: null
	,from: null
	,result: null
	,busy: null
});
var tink_core_Outcome = $hxEnums["tink.core.Outcome"] = { __ename__:"tink.core.Outcome",__constructs__:null
	,Success: ($_=function(data) { return {_hx_index:0,data:data,__enum__:"tink.core.Outcome",toString:$estr}; },$_._hx_name="Success",$_.__params__ = ["data"],$_)
	,Failure: ($_=function(failure) { return {_hx_index:1,failure:failure,__enum__:"tink.core.Outcome",toString:$estr}; },$_._hx_name="Failure",$_.__params__ = ["failure"],$_)
};
tink_core_Outcome.__constructs__ = [tink_core_Outcome.Success,tink_core_Outcome.Failure];
class tink_core_MPair {
	constructor(a,b) {
		this.a = a;
		this.b = b;
	}
}
tink_core_MPair.__name__ = "tink.core.MPair";
Object.assign(tink_core_MPair.prototype, {
	__class__: tink_core_MPair
	,a: null
	,b: null
});
class utest_Assert {
	static isTrue(cond,msg,pos) {
		if(utest_Assert.results == null) {
			throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
		}
		if(cond) {
			utest_Assert.results.add(utest_Assertation.Success(pos));
		} else {
			utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected true",pos));
		}
		return cond;
	}
	static notEquals(expected,value,msg,pos) {
		let cond = expected != value;
		if(utest_Assert.results == null) {
			throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
		}
		if(cond) {
			utest_Assert.results.add(utest_Assertation.Success(pos));
		} else {
			utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected " + utest_Assert.q(expected) + " and test value " + utest_Assert.q(value) + " should be different",pos));
		}
		return cond;
	}
	static equals(expected,value,msg,pos) {
		let cond = expected == value;
		if(utest_Assert.results == null) {
			throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
		}
		if(cond) {
			utest_Assert.results.add(utest_Assertation.Success(pos));
		} else {
			utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value),pos));
		}
		return cond;
	}
	static _floatEquals(expected,value,approx) {
		if(isNaN(expected)) {
			return isNaN(value);
		} else if(isNaN(value)) {
			return false;
		} else if(!isFinite(expected) && !isFinite(value)) {
			return expected > 0 == value > 0;
		}
		if(null == approx) {
			approx = 1e-5;
		}
		return Math.abs(value - expected) <= approx;
	}
	static getTypeName(v) {
		let _g = Type.typeof(v);
		switch(_g._hx_index) {
		case 0:
			return "`null`";
		case 1:
			return "Int";
		case 2:
			return "Float";
		case 3:
			return "Bool";
		case 4:
			return "Object";
		case 5:
			return "function";
		case 6:
			let c = _g.c;
			return c.__name__;
		case 7:
			let e = _g.e;
			return e.__ename__;
		case 8:
			return "`Unknown`";
		}
	}
	static isIterable(v,isAnonym) {
		let fields = isAnonym ? Reflect.fields(v) : Type.getInstanceFields(js_Boot.getClass(v));
		if(!Lambda.has(fields,"iterator")) {
			return false;
		}
		return Reflect.isFunction(Reflect.field(v,"iterator"));
	}
	static isIterator(v,isAnonym) {
		let fields = isAnonym ? Reflect.fields(v) : Type.getInstanceFields(js_Boot.getClass(v));
		if(!Lambda.has(fields,"next") || !Lambda.has(fields,"hasNext")) {
			return false;
		}
		if(Reflect.isFunction(Reflect.field(v,"next"))) {
			return Reflect.isFunction(Reflect.field(v,"hasNext"));
		} else {
			return false;
		}
	}
	static sameAs(expected,value,status,approx) {
		let texpected = utest_Assert.getTypeName(expected);
		let tvalue = utest_Assert.getTypeName(value);
		status.expectedValue = expected;
		status.actualValue = value;
		if(texpected != tvalue && !(texpected == "Int" && tvalue == "Float" || texpected == "Float" && tvalue == "Int")) {
			status.error = "expected type " + texpected + " but it is " + tvalue + (status.path == "" ? "" : " for field " + status.path);
			return false;
		}
		let _g = Type.typeof(expected);
		switch(_g._hx_index) {
		case 0:case 3:
			if(expected != value) {
				status.error = "expected " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value) + (status.path == "" ? "" : " for field " + status.path);
				return false;
			}
			return true;
		case 1:case 2:
			if(!utest_Assert._floatEquals(expected,value,approx)) {
				status.error = "expected " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value) + (status.path == "" ? "" : " for field " + status.path);
				return false;
			}
			return true;
		case 4:
			if(status.recursive || status.path == "") {
				let tfields = Reflect.fields(value);
				let fields = Reflect.fields(expected);
				let path = status.path;
				let _g = 0;
				while(_g < fields.length) {
					let field = fields[_g];
					++_g;
					HxOverrides.remove(tfields,field);
					status.path = path == "" ? field : path + "." + field;
					if(!Object.prototype.hasOwnProperty.call(value,field)) {
						status.error = "expected field " + status.path + " does not exist in " + utest_Assert.q(value);
						return false;
					}
					let e = Reflect.field(expected,field);
					if(Reflect.isFunction(e)) {
						continue;
					}
					let v = Reflect.field(value,field);
					if(!utest_Assert.sameAs(e,v,status,approx)) {
						return false;
					}
				}
				if(tfields.length > 0) {
					status.error = "the tested object has extra field(s) (" + tfields.join(", ") + ") not included in the expected ones";
					return false;
				}
			}
			if(utest_Assert.isIterator(expected,true)) {
				if(!utest_Assert.isIterator(value,true)) {
					status.error = "expected Iterable but it is not " + (status.path == "" ? "" : " for field " + status.path);
					return false;
				}
				if(status.recursive || status.path == "") {
					let evalues = Lambda.array({ iterator : function() {
						return expected;
					}});
					let vvalues = Lambda.array({ iterator : function() {
						return value;
					}});
					if(evalues.length != vvalues.length) {
						status.error = "expected " + evalues.length + " values in Iterator but they are " + vvalues.length + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
					let path = status.path;
					let _g = 0;
					let _g1 = evalues.length;
					while(_g < _g1) {
						let i = _g++;
						status.path = path == "" ? "iterator[" + i + "]" : path + "[" + i + "]";
						if(!utest_Assert.sameAs(evalues[i],vvalues[i],status,approx)) {
							status.error = "expected " + utest_Assert.q(status.expectedValue) + " but it is " + utest_Assert.q(status.actualValue) + (status.path == "" ? "" : " for field " + status.path);
							return false;
						}
					}
				}
				return true;
			}
			if(utest_Assert.isIterable(expected,true)) {
				if(!utest_Assert.isIterable(value,true)) {
					status.error = "expected Iterator but it is not " + (status.path == "" ? "" : " for field " + status.path);
					return false;
				}
				if(status.recursive || status.path == "") {
					let evalues = Lambda.array(expected);
					let vvalues = Lambda.array(value);
					if(evalues.length != vvalues.length) {
						status.error = "expected " + evalues.length + " values in Iterable but they are " + vvalues.length + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
					let path = status.path;
					let _g = 0;
					let _g1 = evalues.length;
					while(_g < _g1) {
						let i = _g++;
						status.path = path == "" ? "iterable[" + i + "]" : path + "[" + i + "]";
						if(!utest_Assert.sameAs(evalues[i],vvalues[i],status,approx)) {
							return false;
						}
					}
				}
				return true;
			}
			return true;
		case 5:
			if(!Reflect.compareMethods(expected,value)) {
				status.error = "expected same function reference" + (status.path == "" ? "" : " for field " + status.path);
				return false;
			}
			return true;
		case 6:
			let c = _g.c;
			let cexpected = c.__name__;
			let c1 = js_Boot.getClass(value);
			let cvalue = c1.__name__;
			if(cexpected != cvalue) {
				status.error = "expected instance of " + utest_Assert.q(cexpected) + " but it is " + utest_Assert.q(cvalue) + (status.path == "" ? "" : " for field " + status.path);
				return false;
			}
			if(typeof(expected) == "string") {
				if(expected == value) {
					return true;
				} else {
					status.error = "expected string '" + Std.string(expected) + "' but it is '" + Std.string(value) + "'";
					return false;
				}
			}
			if(((expected) instanceof Array)) {
				if(status.recursive || status.path == "") {
					if(expected.length != value.length) {
						status.error = "expected " + Std.string(expected.length) + " elements but they are " + Std.string(value.length) + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
					let path = status.path;
					let _g = 0;
					let _g1 = expected.length;
					while(_g < _g1) {
						let i = _g++;
						status.path = path == "" ? "array[" + i + "]" : path + "[" + i + "]";
						if(!utest_Assert.sameAs(expected[i],value[i],status,approx)) {
							status.error = "expected array element at [" + i + "] to have " + utest_Assert.q(status.expectedValue) + " but it is " + utest_Assert.q(status.actualValue) + (status.path == "" ? "" : " for field " + status.path);
							return false;
						}
					}
				}
				return true;
			}
			if(((expected) instanceof Date)) {
				if(expected.getTime() != value.getTime()) {
					status.error = "expected " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value) + (status.path == "" ? "" : " for field " + status.path);
					return false;
				}
				return true;
			}
			if(((expected) instanceof haxe_io_Bytes)) {
				if(status.recursive || status.path == "") {
					let ebytes = expected;
					let vbytes = value;
					if(ebytes.length != vbytes.length) {
						status.error = "expected " + ebytes.length + " bytes length but it is " + vbytes.length;
						return false;
					}
					let _g = 0;
					let _g1 = ebytes.length;
					while(_g < _g1) {
						let i = _g++;
						if(ebytes.b[i] != vbytes.b[i]) {
							status.error = "expected byte #" + i + " to be " + ebytes.b[i] + " but it is " + vbytes.b[i] + (status.path == "" ? "" : " for field " + status.path);
							return false;
						}
					}
				}
				return true;
			}
			if(js_Boot.__implements(expected,haxe_IMap)) {
				if(status.recursive || status.path == "") {
					let map = js_Boot.__cast(expected , haxe_IMap);
					let vmap = js_Boot.__cast(value , haxe_IMap);
					let _g = [];
					let k = map.keys();
					while(k.hasNext()) {
						let k1 = k.next();
						_g.push(k1);
					}
					let keys = _g;
					let _g1 = [];
					let k1 = vmap.keys();
					while(k1.hasNext()) {
						let k = k1.next();
						_g1.push(k);
					}
					let vkeys = _g1;
					if(keys.length != vkeys.length) {
						status.error = "expected " + keys.length + " keys but they are " + vkeys.length + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
					let path = status.path;
					let _g2 = 0;
					while(_g2 < keys.length) {
						let key = keys[_g2];
						++_g2;
						status.path = path == "" ? "hash[" + Std.string(key) + "]" : path + "[" + Std.string(key) + "]";
						if(!utest_Assert.sameAs(map.get(key),vmap.get(key),status,approx)) {
							status.error = "expected " + utest_Assert.q(status.expectedValue) + " but it is " + utest_Assert.q(status.actualValue) + (status.path == "" ? "" : " for field " + status.path);
							return false;
						}
					}
				}
				return true;
			}
			if(utest_Assert.isIterator(expected,false)) {
				if(status.recursive || status.path == "") {
					let evalues = Lambda.array({ iterator : function() {
						return expected;
					}});
					let vvalues = Lambda.array({ iterator : function() {
						return value;
					}});
					if(evalues.length != vvalues.length) {
						status.error = "expected " + evalues.length + " values in Iterator but they are " + vvalues.length + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
					let path = status.path;
					let _g = 0;
					let _g1 = evalues.length;
					while(_g < _g1) {
						let i = _g++;
						status.path = path == "" ? "iterator[" + i + "]" : path + "[" + i + "]";
						if(!utest_Assert.sameAs(evalues[i],vvalues[i],status,approx)) {
							status.error = "expected " + utest_Assert.q(status.expectedValue) + " but it is " + utest_Assert.q(status.actualValue) + (status.path == "" ? "" : " for field " + status.path);
							return false;
						}
					}
				}
				return true;
			}
			if(utest_Assert.isIterable(expected,false)) {
				if(status.recursive || status.path == "") {
					let evalues = Lambda.array(expected);
					let vvalues = Lambda.array(value);
					if(evalues.length != vvalues.length) {
						status.error = "expected " + evalues.length + " values in Iterable but they are " + vvalues.length + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
					let path = status.path;
					let _g = 0;
					let _g1 = evalues.length;
					while(_g < _g1) {
						let i = _g++;
						status.path = path == "" ? "iterable[" + i + "]" : path + "[" + i + "]";
						if(!utest_Assert.sameAs(evalues[i],vvalues[i],status,approx)) {
							return false;
						}
					}
				}
				return true;
			}
			if(status.recursive || status.path == "") {
				let fields = Type.getInstanceFields(js_Boot.getClass(expected));
				let path = status.path;
				let _g = 0;
				while(_g < fields.length) {
					let field = fields[_g];
					++_g;
					status.path = path == "" ? field : path + "." + field;
					let e = Reflect.field(expected,field);
					if(Reflect.isFunction(e)) {
						continue;
					}
					let v = Reflect.field(value,field);
					if(!utest_Assert.sameAs(e,v,status,approx)) {
						return false;
					}
				}
			}
			return true;
		case 7:
			let e = _g.e;
			let eexpected = e.__ename__;
			let e1 = Type.getEnum(value);
			let evalue = e1.__ename__;
			if(eexpected != evalue) {
				status.error = "expected enumeration of " + utest_Assert.q(eexpected) + " but it is " + utest_Assert.q(evalue) + (status.path == "" ? "" : " for field " + status.path);
				return false;
			}
			if(status.recursive || status.path == "") {
				if(expected._hx_index != value._hx_index) {
					let e = expected;
					let tmp = "expected enum constructor " + utest_Assert.q($hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name) + " but it is ";
					let e1 = value;
					status.error = tmp + utest_Assert.q($hxEnums[e1.__enum__].__constructs__[e1._hx_index]._hx_name) + (status.path == "" ? "" : " for field " + status.path);
					return false;
				}
				let eparams = Type.enumParameters(expected);
				let vparams = Type.enumParameters(value);
				let path = status.path;
				let _g = 0;
				let _g1 = eparams.length;
				while(_g < _g1) {
					let i = _g++;
					status.path = path == "" ? "enum[" + i + "]" : path + "[" + i + "]";
					if(!utest_Assert.sameAs(eparams[i],vparams[i],status,approx)) {
						status.error = "expected enum param " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value) + (status.path == "" ? "" : " for field " + status.path) + " with " + status.error;
						return false;
					}
				}
			}
			return true;
		case 8:
			throw haxe_Exception.thrown("Unable to compare two unknown types");
		}
	}
	static q(v) {
		if(typeof(v) == "string") {
			return "\"" + StringTools.replace(v,"\"","\\\"") + "\"";
		} else {
			return Std.string(v);
		}
	}
	static same(expected,value,recursive,msg,approx,pos) {
		if(null == approx) {
			approx = 1e-5;
		}
		let status = { recursive : null == recursive ? true : recursive, path : "", error : null, expectedValue : expected, actualValue : value};
		if(utest_Assert.sameAs(expected,value,status,approx)) {
			return utest_Assert.pass(msg,pos);
		} else {
			return utest_Assert.fail(msg == null ? status.error : msg,pos);
		}
	}
	static pass(msg,pos) {
		if(msg == null) {
			msg = "pass expected";
		}
		return utest_Assert.isTrue(true,msg,pos);
	}
	static fail(msg,pos) {
		if(msg == null) {
			msg = "failure expected";
		}
		return utest_Assert.isTrue(false,msg,pos);
	}
	static createAsync(f,timeout) {
		return function() {
		};
	}
	static createEvent(f,timeout) {
		return function(e) {
		};
	}
}
utest_Assert.__name__ = "utest.Assert";
var utest_Assertation = $hxEnums["utest.Assertation"] = { __ename__:"utest.Assertation",__constructs__:null
	,Success: ($_=function(pos) { return {_hx_index:0,pos:pos,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="Success",$_.__params__ = ["pos"],$_)
	,Failure: ($_=function(msg,pos) { return {_hx_index:1,msg:msg,pos:pos,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="Failure",$_.__params__ = ["msg","pos"],$_)
	,Error: ($_=function(e,stack) { return {_hx_index:2,e:e,stack:stack,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="Error",$_.__params__ = ["e","stack"],$_)
	,SetupError: ($_=function(e,stack) { return {_hx_index:3,e:e,stack:stack,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="SetupError",$_.__params__ = ["e","stack"],$_)
	,TeardownError: ($_=function(e,stack) { return {_hx_index:4,e:e,stack:stack,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="TeardownError",$_.__params__ = ["e","stack"],$_)
	,TimeoutError: ($_=function(missedAsyncs,stack) { return {_hx_index:5,missedAsyncs:missedAsyncs,stack:stack,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="TimeoutError",$_.__params__ = ["missedAsyncs","stack"],$_)
	,AsyncError: ($_=function(e,stack) { return {_hx_index:6,e:e,stack:stack,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="AsyncError",$_.__params__ = ["e","stack"],$_)
	,Warning: ($_=function(msg) { return {_hx_index:7,msg:msg,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="Warning",$_.__params__ = ["msg"],$_)
	,Ignore: ($_=function(reason) { return {_hx_index:8,reason:reason,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="Ignore",$_.__params__ = ["reason"],$_)
};
utest_Assertation.__constructs__ = [utest_Assertation.Success,utest_Assertation.Failure,utest_Assertation.Error,utest_Assertation.SetupError,utest_Assertation.TeardownError,utest_Assertation.TimeoutError,utest_Assertation.AsyncError,utest_Assertation.Warning,utest_Assertation.Ignore];
class utest_Async {
	constructor(timeoutMs) {
		if(timeoutMs == null) {
			timeoutMs = 250;
		}
		this.callbacks = [];
		this.timedOut = false;
		this.resolved = false;
		this.timeoutMs = timeoutMs;
		let hrtime = process.hrtime();
		this.startTime = hrtime[0] + hrtime[1] / 1e9;
		this.timer = haxe_Timer.delay($bind(this,this.setTimedOutState),timeoutMs);
	}
	done(pos) {
		if(this.resolved) {
			if(this.timedOut) {
				throw haxe_Exception.thrown("Cannot done() at " + pos.fileName + ":" + pos.lineNumber + " because async is timed out.");
			} else {
				throw haxe_Exception.thrown("Cannot done() at " + pos.fileName + ":" + pos.lineNumber + " because async is done already.");
			}
		}
		this.resolved = true;
		this.timer.stop();
		let _g = 0;
		let _g1 = this.callbacks;
		while(_g < _g1.length) {
			let cb = _g1[_g];
			++_g;
			cb();
		}
	}
	setTimeout(timeoutMs,pos) {
		if(this.resolved) {
			throw haxe_Exception.thrown("Cannot setTimeout(" + timeoutMs + ") at " + pos.fileName + ":" + pos.lineNumber + " because async is done.");
		}
		if(this.timedOut) {
			throw haxe_Exception.thrown("Cannot setTimeout(" + timeoutMs + ") at " + pos.fileName + ":" + pos.lineNumber + " because async is timed out.");
		}
		this.timer.stop();
		this.timeoutMs = timeoutMs;
		let hrtime = process.hrtime();
		let delay = timeoutMs - Math.round(1000 * (hrtime[0] + hrtime[1] / 1e9 - this.startTime));
		this.timer = haxe_Timer.delay($bind(this,this.setTimedOutState),delay);
	}
	then(cb) {
		if(this.resolved) {
			cb();
		} else {
			this.callbacks.push(cb);
		}
	}
	setTimedOutState() {
		if(this.resolved) {
			return;
		}
		this.timedOut = true;
		this.done({ fileName : "utest/Async.hx", lineNumber : 115, className : "utest.Async", methodName : "setTimedOutState"});
	}
	static getResolved() {
		if(utest_Async.resolvedInstance == null) {
			utest_Async.resolvedInstance = new utest_Async();
			utest_Async.resolvedInstance.done({ fileName : "utest/Async.hx", lineNumber : 30, className : "utest.Async", methodName : "getResolved"});
		}
		return utest_Async.resolvedInstance;
	}
}
utest_Async.__name__ = "utest.Async";
Object.assign(utest_Async.prototype, {
	__class__: utest_Async
	,resolved: null
	,timedOut: null
	,callbacks: null
	,timeoutMs: null
	,startTime: null
	,timer: null
});
var utest__$Dispatcher_EventException = $hxEnums["utest._Dispatcher.EventException"] = { __ename__:"utest._Dispatcher.EventException",__constructs__:null
	,StopPropagation: {_hx_name:"StopPropagation",_hx_index:0,__enum__:"utest._Dispatcher.EventException",toString:$estr}
};
utest__$Dispatcher_EventException.__constructs__ = [utest__$Dispatcher_EventException.StopPropagation];
class utest_Dispatcher {
	constructor() {
		this.handlers = [];
	}
	add(h) {
		this.handlers.push(h);
		return h;
	}
	dispatch(e) {
		try {
			let list = this.handlers.slice();
			let _g = 0;
			while(_g < list.length) {
				let l = list[_g];
				++_g;
				l(e);
			}
			return true;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(js_Boot.__instanceof(haxe_Exception.caught(_g).unwrap(),utest__$Dispatcher_EventException)) {
				return false;
			} else {
				throw _g;
			}
		}
	}
}
utest_Dispatcher.__name__ = "utest.Dispatcher";
Object.assign(utest_Dispatcher.prototype, {
	__class__: utest_Dispatcher
	,handlers: null
});
class utest_Notifier {
	constructor() {
		this.handlers = [];
	}
	dispatch() {
		try {
			let list = this.handlers.slice();
			let _g = 0;
			while(_g < list.length) {
				let l = list[_g];
				++_g;
				l();
			}
			return true;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(js_Boot.__instanceof(haxe_Exception.caught(_g).unwrap(),utest__$Dispatcher_EventException)) {
				return false;
			} else {
				throw _g;
			}
		}
	}
}
utest_Notifier.__name__ = "utest.Notifier";
Object.assign(utest_Notifier.prototype, {
	__class__: utest_Notifier
	,handlers: null
});
class utest_TestHandler {
	constructor(fixture) {
		this.wasBound = false;
		this.finished = false;
		if(fixture == null) {
			throw haxe_Exception.thrown("fixture argument is null");
		}
		this.fixture = fixture;
		this.results = new haxe_ds_List();
		this.asyncStack = new haxe_ds_List();
		this.onTested = new utest_Dispatcher();
		this.onTimeout = new utest_Dispatcher();
		this.onComplete = new utest_Dispatcher();
		this.onPrecheck = new utest_Dispatcher();
		if(fixture.ignoringInfo != null) {
			this.results.add(utest_Assertation.Ignore(fixture.ignoringInfo));
		}
	}
	execute() {
		if(this.fixture.ignoringInfo != null) {
			this.executeFinally();
			return;
		}
		let isSync = true;
		let expectingAsync = true;
		let _gthis = this;
		let run = function() {
			if(isSync) {
				expectingAsync = false;
				return;
			}
			_gthis.executeFixtureMethod();
			_gthis.executeFinally();
		};
		try {
			this.executeMethod(this.fixture.setup);
			this.executeAsyncMethod(this.fixture.setupAsync,run);
			if(!expectingAsync) {
				this.executeFixtureMethod();
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.SetupError(_g1,utest_TestHandler.exceptionStack()));
		}
		isSync = false;
		if(!expectingAsync) {
			this.executeFinally();
		}
	}
	executeFixtureMethod() {
		try {
			this.executeMethod(this.fixture.method);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.Error(_g1,utest_TestHandler.exceptionStack()));
		}
	}
	executeFinally() {
		this.onPrecheck.dispatch(this);
		this.checkTested();
	}
	checkTested() {
		if(this.expiration == null || this.asyncStack.length == 0) {
			this.tested();
		} else {
			let hrtime = process.hrtime();
			if(hrtime[0] + hrtime[1] / 1e9 > this.expiration) {
				this.timeout();
			} else {
				haxe_Timer.delay($bind(this,this.checkTested),10);
			}
		}
	}
	setTimeout(timeout) {
		let hrtime = process.hrtime();
		let newExpire = hrtime[0] + hrtime[1] / 1e9 + timeout / 1000;
		this.expiration = this.expiration == null ? newExpire : newExpire > this.expiration ? newExpire : this.expiration;
	}
	bindHandler() {
		if(this.wasBound) {
			return;
		}
		utest_Assert.results = this.results;
		utest_Assert.createAsync = $bind(this,this.addAsync);
		utest_Assert.createEvent = $bind(this,this.addEvent);
		this.wasBound = true;
	}
	unbindHandler() {
		if(!this.wasBound) {
			return;
		}
		utest_Assert.results = null;
		utest_Assert.createAsync = function(f,t) {
			return function() {
			};
		};
		utest_Assert.createEvent = function(f,t) {
			return function(e) {
			};
		};
		this.wasBound = false;
	}
	addAsync(f,timeout) {
		if(timeout == null) {
			timeout = 250;
		}
		if(null == f) {
			f = function() {
			};
		}
		this.asyncStack.add(f);
		let handler = this;
		this.setTimeout(timeout);
		return function() {
			if(!handler.asyncStack.remove(f)) {
				handler.results.add(utest_Assertation.AsyncError("async function already executed",[]));
				return;
			}
			try {
				handler.bindHandler();
				f();
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				handler.results.add(utest_Assertation.AsyncError(_g1,utest_TestHandler.exceptionStack(0)));
			}
		};
	}
	addEvent(f,timeout) {
		if(timeout == null) {
			timeout = 250;
		}
		this.asyncStack.add(f);
		let handler = this;
		this.setTimeout(timeout);
		return function(e) {
			if(!handler.asyncStack.remove(f)) {
				handler.results.add(utest_Assertation.AsyncError("event already executed",[]));
				return;
			}
			try {
				handler.bindHandler();
				f(e);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				handler.results.add(utest_Assertation.AsyncError(_g1,utest_TestHandler.exceptionStack(0)));
			}
		};
	}
	executeMethod(name) {
		if(name == null) {
			return;
		}
		this.bindHandler();
		Reflect.field(this.fixture.target,name).apply(this.fixture.target,[]);
	}
	executeAsyncMethod(name,done) {
		if(name == null) {
			done();
			return;
		}
		this.bindHandler();
		Reflect.field(this.fixture.target,name).apply(this.fixture.target,[done]);
	}
	tested() {
		if(this.results.length == 0) {
			this.results.add(utest_Assertation.Warning("no assertions"));
		}
		this.onTested.dispatch(this);
		this.completed();
	}
	timeout() {
		this.results.add(utest_Assertation.TimeoutError(this.asyncStack.length,[]));
		this.onTimeout.dispatch(this);
		this.completed();
	}
	completed() {
		if(this.fixture.ignoringInfo != null) {
			this.completedFinally();
			return;
		}
		let isSync = true;
		let expectingAsync = true;
		let _gthis = this;
		let complete = function() {
			if(isSync) {
				expectingAsync = false;
				return;
			}
			_gthis.completedFinally();
		};
		try {
			this.executeMethod(this.fixture.teardown);
			this.executeAsyncMethod(this.fixture.teardownAsync,complete);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.TeardownError(_g1,utest_TestHandler.exceptionStack(2)));
		}
		isSync = false;
		if(!expectingAsync) {
			this.completedFinally();
		}
	}
	completedFinally() {
		this.finished = true;
		this.unbindHandler();
		this.onComplete.dispatch(this);
	}
	static exceptionStack(pops) {
		if(pops == null) {
			pops = 2;
		}
		let stack = haxe_CallStack.exceptionStack();
		while(pops-- > 0) stack.pop();
		return stack;
	}
}
utest_TestHandler.__name__ = "utest.TestHandler";
Object.assign(utest_TestHandler.prototype, {
	__class__: utest_TestHandler
	,results: null
	,fixture: null
	,finished: null
	,asyncStack: null
	,onTested: null
	,onTimeout: null
	,onComplete: null
	,onPrecheck: null
	,wasBound: null
	,expiration: null
});
class utest_ITestHandler extends utest_TestHandler {
	constructor(fixture) {
		super(fixture);
		if(!fixture.isITest) {
			throw haxe_Exception.thrown("Invalid fixture type for utest.ITestHandler");
		}
		this.testCase = js_Boot.__cast(fixture.target , utest_ITest);
		this.test = fixture.test;
		if(this.test == null) {
			throw haxe_Exception.thrown("Fixture is missing test data");
		}
	}
	execute() {
		if(this.fixture.ignoringInfo != null) {
			this.executeFinally();
			return;
		}
		this.bindHandler();
		this.runSetup();
	}
	runSetup() {
		try {
			this.setupAsync = this.fixture.setupMethod();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.SetupError(_g1,haxe_CallStack.exceptionStack()));
			this.completedFinally();
			return;
		}
		this.setupAsync.then($bind(this,this.checkSetup));
	}
	checkSetup() {
		if(this.setupAsync.timedOut) {
			this.results.add(utest_Assertation.SetupError("Setup timeout",[]));
			this.completedFinally();
		} else {
			this.runTest();
		}
	}
	runTest() {
		try {
			this.testAsync = this.test.execute();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.Error(_g1,haxe_CallStack.exceptionStack()));
			this.runTeardown();
			return;
		}
		this.testAsync.then($bind(this,this.checkTest));
	}
	checkTest() {
		this.onPrecheck.dispatch(this);
		if(this.testAsync.timedOut) {
			this.results.add(utest_Assertation.TimeoutError(1,[]));
			this.onTimeout.dispatch(this);
		} else if(this.testAsync.resolved) {
			if(this.results.length == 0) {
				this.results.add(utest_Assertation.Warning("no assertions"));
			}
			this.onTested.dispatch(this);
		} else {
			throw haxe_Exception.thrown("Unexpected test state");
		}
		this.runTeardown();
	}
	runTeardown() {
		try {
			this.teardownAsync = this.fixture.teardownMethod();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.TeardownError(_g1,haxe_CallStack.exceptionStack()));
			this.completedFinally();
			return;
		}
		this.teardownAsync.then($bind(this,this.checkTeardown));
	}
	checkTeardown() {
		if(this.teardownAsync.timedOut) {
			this.results.add(utest_Assertation.TeardownError("Teardown timeout",[]));
		}
		this.completedFinally();
	}
	bindHandler() {
		if(this.wasBound) {
			return;
		}
		utest_Assert.results = this.results;
		let msg = " is not allowed in tests extending utest.ITest. Add `async:utest.Async` argument to the test method instead.";
		utest_Assert.createAsync = function(f,t) {
			throw haxe_Exception.thrown("Assert.createAsync() " + msg);
		};
		utest_Assert.createEvent = function(f,t) {
			throw haxe_Exception.thrown("Assert.createEvent() " + msg);
		};
		this.wasBound = true;
	}
}
utest_ITestHandler.__name__ = "utest.ITestHandler";
utest_ITestHandler.__super__ = utest_TestHandler;
Object.assign(utest_ITestHandler.prototype, {
	__class__: utest_ITestHandler
	,testCase: null
	,test: null
	,setupAsync: null
	,testAsync: null
	,teardownAsync: null
});
class utest_IgnoredFixture {
	static NotIgnored() {
		return null;
	}
	static Ignored(reason) {
		let this1 = reason != null ? reason : "";
		return this1;
	}
}
class utest_Runner {
	constructor() {
		this.executedFixtures = 0;
		this.pos = 0;
		this.complete = false;
		this.globalPattern = null;
		this.iTestFixtures = new haxe_ds_StringMap();
		this.fixtures = [];
		this.onProgress = new utest_Dispatcher();
		this.onStart = new utest_Dispatcher();
		this.onComplete = new utest_Dispatcher();
		this.onPrecheck = new utest_Dispatcher();
		this.onTestStart = new utest_Dispatcher();
		this.onTestComplete = new utest_Dispatcher();
		this.length = 0;
	}
	addCase(test,setup,teardown,prefix,pattern,setupAsync,teardownAsync) {
		if(teardownAsync == null) {
			teardownAsync = "teardownAsync";
		}
		if(setupAsync == null) {
			setupAsync = "setupAsync";
		}
		if(prefix == null) {
			prefix = "test";
		}
		if(teardown == null) {
			teardown = "teardown";
		}
		if(setup == null) {
			setup = "setup";
		}
		if(js_Boot.__implements(test,utest_ITest)) {
			this.addITest(test,pattern);
		} else {
			this.addCaseOld(test,setup,teardown,prefix,pattern,setupAsync,teardownAsync);
		}
	}
	addITest(testCase,pattern) {
		let c = js_Boot.getClass(testCase);
		let className = c.__name__;
		if(Object.prototype.hasOwnProperty.call(this.iTestFixtures.h,className)) {
			throw haxe_Exception.thrown("Cannot add the same test twice.");
		}
		let fixtures = [];
		let init = testCase.__initializeUtest__();
		let _g = 0;
		let _g1 = init.tests;
		while(_g < _g1.length) {
			let test = _g1[_g];
			++_g;
			if(!this.isTestFixtureName(className,test.name,["test","spec"],pattern,this.globalPattern)) {
				continue;
			}
			let fixture = utest_TestFixture.ofData(testCase,test,init.accessories);
			this.addFixture(fixture);
			fixtures.push(fixture);
		}
		if(fixtures.length > 0) {
			this.iTestFixtures.h[className] = { caseInstance : testCase, setupClass : utest_utils_AccessoriesUtils.getSetupClass(init.accessories), dependencies : init.dependencies, fixtures : fixtures, teardownClass : utest_utils_AccessoriesUtils.getTeardownClass(init.accessories)};
		}
	}
	addCaseOld(test,setup,teardown,prefix,pattern,setupAsync,teardownAsync) {
		if(teardownAsync == null) {
			teardownAsync = "teardownAsync";
		}
		if(setupAsync == null) {
			setupAsync = "setupAsync";
		}
		if(prefix == null) {
			prefix = "test";
		}
		if(teardown == null) {
			teardown = "teardown";
		}
		if(setup == null) {
			setup = "setup";
		}
		if(!Reflect.isObject(test)) {
			throw haxe_Exception.thrown("can't add a null object as a test case");
		}
		if(!this.isMethod(test,setup)) {
			setup = null;
		}
		if(!this.isMethod(test,setupAsync)) {
			setupAsync = null;
		}
		if(!this.isMethod(test,teardown)) {
			teardown = null;
		}
		if(!this.isMethod(test,teardownAsync)) {
			teardownAsync = null;
		}
		let fields = Type.getInstanceFields(js_Boot.getClass(test));
		let c = js_Boot.getClass(test);
		let className = c.__name__;
		let _g = 0;
		while(_g < fields.length) {
			let field = fields[_g];
			++_g;
			if(!this.isMethod(test,field)) {
				continue;
			}
			if(!this.isTestFixtureName(className,field,[prefix],pattern,this.globalPattern)) {
				continue;
			}
			this.addFixture(new utest_TestFixture(test,field,setup,teardown,setupAsync,teardownAsync));
		}
	}
	isTestFixtureName(caseName,testName,prefixes,pattern,globalPattern) {
		if(pattern == null && globalPattern == null) {
			let _g = 0;
			while(_g < prefixes.length) {
				let prefix = prefixes[_g];
				++_g;
				if(testName.startsWith(prefix)) {
					return true;
				}
			}
			return false;
		}
		if(pattern == null) {
			pattern = globalPattern;
		}
		return pattern.match("" + caseName + "." + testName);
	}
	addFixture(fixture) {
		this.fixtures.push(fixture);
		this.length++;
	}
	getFixture(index) {
		return this.fixtures[index];
	}
	isMethod(test,name) {
		try {
			return Reflect.isFunction(Reflect.field(test,name));
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return false;
		}
	}
	run() {
		this.onStart.dispatch(this);
		let iTestRunner = new utest__$Runner_ITestRunner(this);
		iTestRunner.run();
		this.waitForCompletion();
	}
	waitForCompletion() {
		if(!this.complete) {
			haxe_Timer.delay($bind(this,this.waitForCompletion),100);
		}
	}
	runNext(finishedHandler) {
		let currentCase = null;
		let _g = this.pos;
		let _g1 = this.fixtures.length;
		while(_g < _g1) {
			_g++;
			let fixture = this.fixtures[this.pos++];
			if(fixture.isITest) {
				continue;
			}
			if(currentCase != fixture.target) {
				currentCase = fixture.target;
				let c = js_Boot.getClass(currentCase);
				c.__name__;
			}
			let handler = this.runFixture(fixture);
			if(!handler.finished) {
				handler.onComplete.add($bind(this,this.runNext));
				return;
			}
		}
		this.complete = true;
		this.onComplete.dispatch(this);
	}
	runFixture(fixture) {
		let handler = fixture.isITest ? new utest_ITestHandler(fixture) : new utest_TestHandler(fixture);
		handler.onComplete.add($bind(this,this.testComplete));
		handler.onPrecheck.add(($_=this.onPrecheck,$bind($_,$_.dispatch)));
		this.onTestStart.dispatch(handler);
		handler.execute();
		return handler;
	}
	testComplete(h) {
		++this.executedFixtures;
		this.onTestComplete.dispatch(h);
		this.onProgress.dispatch({ result : utest_TestResult.ofHandler(h), done : this.executedFixtures, totals : this.length});
	}
}
utest_Runner.__name__ = "utest.Runner";
Object.assign(utest_Runner.prototype, {
	__class__: utest_Runner
	,fixtures: null
	,iTestFixtures: null
	,onProgress: null
	,onStart: null
	,onComplete: null
	,onPrecheck: null
	,onTestStart: null
	,onTestComplete: null
	,length: null
	,globalPattern: null
	,complete: null
	,pos: null
	,executedFixtures: null
});
class utest__$Runner_ITestRunner {
	constructor(runner) {
		this.failedCases = [];
		this.failedTestsInCurrentCase = [];
		let _gthis = this;
		this.runner = runner;
		runner.onTestComplete.add(function(handler) {
			let _g_head = handler.results.h;
			while(_g_head != null) {
				let val = _g_head.item;
				_g_head = _g_head.next;
				let result = val;
				if(result._hx_index != 0) {
					_gthis.failedTestsInCurrentCase.push(handler.fixture.method);
					let c = js_Boot.getClass(handler.fixture.target);
					_gthis.failedCases.push(c.__name__);
				}
			}
		});
	}
	run() {
		this.cases = this.orderClassesByDependencies();
		this.runCases();
	}
	orderClassesByDependencies() {
		let result = [];
		let _gthis = this;
		let error = function(testCase,msg) {
			_gthis.runner.onProgress.dispatch({ totals : _gthis.runner.length, result : utest_TestResult.ofFailedSetupClass(testCase,utest_Assertation.SetupError(msg,[])), done : _gthis.runner.executedFixtures});
		};
		let added_h = Object.create(null);
		let addClass = null;
		addClass = function(cls,stack) {
			if(Object.prototype.hasOwnProperty.call(added_h,cls)) {
				return;
			}
			let data = _gthis.runner.iTestFixtures.h[cls];
			if(stack.indexOf(cls) >= 0) {
				error(data.caseInstance,"Circular dependencies among test classes detected: " + stack.join(" -> "));
				return;
			}
			stack.push(cls);
			let dependencies = data.dependencies;
			let _g = 0;
			while(_g < dependencies.length) {
				let dependency = dependencies[_g];
				++_g;
				if(Object.prototype.hasOwnProperty.call(_gthis.runner.iTestFixtures.h,dependency)) {
					addClass(dependency,stack);
				} else {
					error(data.caseInstance,"This class depends on " + dependency + ", but it cannot be found. Was it added to test runner?");
					return;
				}
			}
			result.push(cls);
			added_h[cls] = true;
		};
		let h = this.runner.iTestFixtures.h;
		let cls_keys = Object.keys(h);
		let cls_length = cls_keys.length;
		let cls_current = 0;
		while(cls_current < cls_length) {
			let cls = cls_keys[cls_current++];
			addClass(cls,[]);
		}
		return new haxe_iterators_ArrayIterator(result);
	}
	failedDependencies(data) {
		let _g = 0;
		let _g1 = data.dependencies;
		while(_g < _g1.length) {
			let dependency = _g1[_g];
			++_g;
			if(this.failedCases.indexOf(dependency) >= 0) {
				return true;
			}
		}
		return false;
	}
	runCases() {
		while(this.cases.hasNext()) {
			this.currentCaseName = this.cases.next();
			let data = this.runner.iTestFixtures.h[this.currentCaseName];
			this.currentCase = data.caseInstance;
			this.failedTestsInCurrentCase = [];
			if(this.failedDependencies(data)) {
				this.failedCases.push(this.currentCaseName);
				continue;
			}
			this.currentCaseFixtures = data.fixtures;
			this.teardownClass = data.teardownClass;
			try {
				this.setupAsync = data.setupClass();
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				this.setupFailed(utest_Assertation.SetupError("setupClass failed: " + Std.string(haxe_Exception.caught(_g).unwrap()),haxe_CallStack.exceptionStack()));
				return;
			}
			if(this.setupAsync.resolved) {
				if(!this.runFixtures()) {
					return;
				}
			} else {
				this.setupAsync.then($bind(this,this.checkSetup));
				return;
			}
		}
		this.runner.runNext();
	}
	checkSetup() {
		if(this.setupAsync.timedOut) {
			this.setupFailed(utest_Assertation.SetupError("setupClass timeout",[]));
		} else {
			this.runFixtures();
		}
	}
	setupFailed(assertation) {
		this.runner.executedFixtures += this.currentCaseFixtures.length;
		this.runner.onProgress.dispatch({ totals : this.runner.length, result : utest_TestResult.ofFailedSetupClass(this.currentCase,assertation), done : this.runner.executedFixtures});
		this.runCases();
	}
	runFixtures(finishedHandler) {
		while(this.currentCaseFixtures.length > 0) {
			let fixture = this.currentCaseFixtures.shift();
			let _g = 0;
			let _g1 = fixture.test.dependencies;
			while(_g < _g1.length) {
				let dep = _g1[_g];
				++_g;
				if(this.failedTestsInCurrentCase.indexOf(dep) >= 0) {
					fixture.ignoringInfo = utest_IgnoredFixture.Ignored("Failed dependencies");
					break;
				}
			}
			let handler = this.runner.runFixture(fixture);
			if(!handler.finished) {
				handler.onComplete.add($bind(this,this.runFixtures));
				return false;
			}
		}
		try {
			this.teardownAsync = this.teardownClass();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			this.teardownFailed(utest_Assertation.TeardownError("teardownClass failed: " + Std.string(haxe_Exception.caught(_g).unwrap()),haxe_CallStack.exceptionStack()));
			return true;
		}
		if(this.teardownAsync.resolved && finishedHandler == null) {
			return true;
		}
		this.teardownAsync.then($bind(this,this.checkTeardown));
		return false;
	}
	checkTeardown() {
		if(this.teardownAsync.timedOut) {
			this.teardownFailed(utest_Assertation.TeardownError("teardownClass timeout",[]));
		}
		this.runCases();
	}
	teardownFailed(assertation) {
		this.runner.onProgress.dispatch({ totals : this.runner.length, result : utest_TestResult.ofFailedTeardownClass(this.currentCase,assertation), done : this.runner.executedFixtures});
	}
}
utest__$Runner_ITestRunner.__name__ = "utest._Runner.ITestRunner";
Object.assign(utest__$Runner_ITestRunner.prototype, {
	__class__: utest__$Runner_ITestRunner
	,runner: null
	,cases: null
	,currentCaseName: null
	,currentCase: null
	,currentCaseFixtures: null
	,teardownClass: null
	,setupAsync: null
	,teardownAsync: null
	,failedTestsInCurrentCase: null
	,failedCases: null
});
class utest_TestFixture {
	constructor(target,method,setup,teardown,setupAsync,teardownAsync) {
		this.isITest = false;
		this.target = target;
		this.method = method;
		this.setup = setup;
		this.setupAsync = setupAsync;
		this.teardown = teardown;
		this.teardownAsync = teardownAsync;
		this.ignoringInfo = this.getIgnored();
	}
	getIgnored() {
		let metas = haxe_rtti_Meta.getFields(js_Boot.getClass(this.target));
		let metasForTestMetas = Reflect.getProperty(metas,this.method);
		if(metasForTestMetas == null || !Object.prototype.hasOwnProperty.call(metasForTestMetas,"Ignored")) {
			return utest_IgnoredFixture.NotIgnored();
		}
		let ignoredArgs = Reflect.getProperty(metasForTestMetas,"Ignored");
		if(ignoredArgs == null || ignoredArgs.length == 0 || ignoredArgs[0] == null) {
			return utest_IgnoredFixture.Ignored();
		}
		let ignoredReason = Std.string(ignoredArgs[0]);
		return utest_IgnoredFixture.Ignored(ignoredReason);
	}
	static ofData(target,test,accessories) {
		let fixture = new utest_TestFixture(target,test.name);
		fixture.isITest = true;
		fixture.test = test;
		fixture.setupMethod = utest_utils_AccessoriesUtils.getSetup(accessories);
		fixture.teardownMethod = utest_utils_AccessoriesUtils.getTeardown(accessories);
		return fixture;
	}
}
utest_TestFixture.__name__ = "utest.TestFixture";
Object.assign(utest_TestFixture.prototype, {
	__class__: utest_TestFixture
	,target: null
	,method: null
	,setup: null
	,setupAsync: null
	,teardown: null
	,teardownAsync: null
	,ignoringInfo: null
	,isITest: null
	,test: null
	,setupMethod: null
	,teardownMethod: null
});
class utest_TestResult {
	constructor() {
	}
	static ofHandler(handler) {
		let r = new utest_TestResult();
		let c = js_Boot.getClass(handler.fixture.target);
		let path = c.__name__.split(".");
		r.cls = path.pop();
		r.pack = path.join(".");
		r.method = handler.fixture.method;
		r.setup = handler.fixture.setup;
		r.setupAsync = handler.fixture.setupAsync;
		r.teardown = handler.fixture.teardown;
		r.teardownAsync = handler.fixture.teardownAsync;
		r.assertations = handler.results;
		return r;
	}
	static ofFailedSetupClass(testCase,assertation) {
		let r = new utest_TestResult();
		let c = js_Boot.getClass(testCase);
		let path = c.__name__.split(".");
		r.cls = path.pop();
		r.pack = path.join(".");
		r.method = "setup";
		r.assertations = new haxe_ds_List();
		r.assertations.add(assertation);
		return r;
	}
	static ofFailedTeardownClass(testCase,assertation) {
		let r = new utest_TestResult();
		let c = js_Boot.getClass(testCase);
		let path = c.__name__.split(".");
		r.cls = path.pop();
		r.pack = path.join(".");
		r.method = "setup";
		r.assertations = new haxe_ds_List();
		r.assertations.add(assertation);
		return r;
	}
}
utest_TestResult.__name__ = "utest.TestResult";
Object.assign(utest_TestResult.prototype, {
	__class__: utest_TestResult
	,pack: null
	,cls: null
	,method: null
	,setup: null
	,setupAsync: null
	,teardown: null
	,teardownAsync: null
	,assertations: null
});
class utest_UTest {
	static run(cases,callback) {
		let runner = new utest_Runner();
		let _g = 0;
		while(_g < cases.length) {
			let eachCase = cases[_g];
			++_g;
			runner.addCase(eachCase);
		}
		if(null != callback) {
			runner.onComplete.add(function(_) {
				callback();
			});
		}
		utest_ui_Report.create(runner);
		runner.run();
	}
}
utest_UTest.__name__ = "utest.UTest";
class utest_ui_Report {
	static create(runner,displaySuccessResults,headerDisplayMode) {
		let report = new utest_ui_text_PrintReport(runner);
		if(null == displaySuccessResults) {
			report.displaySuccessResults = utest_ui_common_SuccessResultsDisplayMode.ShowSuccessResultsWithNoErrors;
		} else {
			report.displaySuccessResults = displaySuccessResults;
		}
		if(null == headerDisplayMode) {
			report.displayHeader = utest_ui_common_HeaderDisplayMode.ShowHeaderWithResults;
		} else {
			report.displayHeader = headerDisplayMode;
		}
		return report;
	}
}
utest_ui_Report.__name__ = "utest.ui.Report";
class utest_ui_common_ClassResult {
	constructor(className,setupName,teardownName) {
		this.fixtures = new haxe_ds_StringMap();
		this.className = className;
		this.setupName = setupName;
		this.hasSetup = setupName != null;
		this.teardownName = teardownName;
		this.hasTeardown = teardownName != null;
		this.methods = 0;
		this.stats = new utest_ui_common_ResultStats();
	}
	add(result) {
		if(Object.prototype.hasOwnProperty.call(this.fixtures.h,result.methodName)) {
			throw haxe_Exception.thrown("invalid duplicated fixture: " + this.className + "." + result.methodName);
		}
		this.stats.wire(result.stats);
		this.methods++;
		this.fixtures.h[result.methodName] = result;
	}
	get(method) {
		return this.fixtures.h[method];
	}
	methodNames(errorsHavePriority) {
		if(errorsHavePriority == null) {
			errorsHavePriority = true;
		}
		let names = [];
		let h = this.fixtures.h;
		let name_keys = Object.keys(h);
		let name_length = name_keys.length;
		let name_current = 0;
		while(name_current < name_length) {
			let name = name_keys[name_current++];
			names.push(name);
		}
		if(errorsHavePriority) {
			let me = this;
			names.sort(function(a,b) {
				let as = me.get(a).stats;
				let bs = me.get(b).stats;
				if(as.hasErrors) {
					if(!bs.hasErrors) {
						return -1;
					} else if(as.errors == bs.errors) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.errors,bs.errors);
					}
				} else if(bs.hasErrors) {
					return 1;
				} else if(as.hasFailures) {
					if(!bs.hasFailures) {
						return -1;
					} else if(as.failures == bs.failures) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.failures,bs.failures);
					}
				} else if(bs.hasFailures) {
					return 1;
				} else if(as.hasWarnings) {
					if(!bs.hasWarnings) {
						return -1;
					} else if(as.warnings == bs.warnings) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.warnings,bs.warnings);
					}
				} else if(bs.hasWarnings) {
					return 1;
				} else {
					return Reflect.compare(a,b);
				}
			});
		} else {
			names.sort(function(a,b) {
				return Reflect.compare(a,b);
			});
		}
		return names;
	}
}
utest_ui_common_ClassResult.__name__ = "utest.ui.common.ClassResult";
Object.assign(utest_ui_common_ClassResult.prototype, {
	__class__: utest_ui_common_ClassResult
	,fixtures: null
	,className: null
	,setupName: null
	,teardownName: null
	,hasSetup: null
	,hasTeardown: null
	,methods: null
	,stats: null
});
class utest_ui_common_FixtureResult {
	constructor(methodName) {
		this.methodName = methodName;
		this.list = new haxe_ds_List();
		this.hasTestError = false;
		this.hasSetupError = false;
		this.hasTeardownError = false;
		this.hasTimeoutError = false;
		this.hasAsyncError = false;
		this.stats = new utest_ui_common_ResultStats();
	}
	iterator() {
		return new haxe_ds__$List_ListIterator(this.list.h);
	}
	add(assertation) {
		this.list.add(assertation);
		switch(assertation._hx_index) {
		case 0:
			this.stats.addSuccesses(1);
			break;
		case 1:
			this.stats.addFailures(1);
			break;
		case 2:
			this.stats.addErrors(1);
			break;
		case 3:
			this.stats.addErrors(1);
			this.hasSetupError = true;
			break;
		case 4:
			this.stats.addErrors(1);
			this.hasTeardownError = true;
			break;
		case 5:
			this.stats.addErrors(1);
			this.hasTimeoutError = true;
			break;
		case 6:
			this.stats.addErrors(1);
			this.hasAsyncError = true;
			break;
		case 7:
			this.stats.addWarnings(1);
			break;
		case 8:
			this.stats.addIgnores(1);
			break;
		}
	}
}
utest_ui_common_FixtureResult.__name__ = "utest.ui.common.FixtureResult";
Object.assign(utest_ui_common_FixtureResult.prototype, {
	__class__: utest_ui_common_FixtureResult
	,methodName: null
	,hasTestError: null
	,hasSetupError: null
	,hasTeardownError: null
	,hasTimeoutError: null
	,hasAsyncError: null
	,stats: null
	,list: null
});
var utest_ui_common_HeaderDisplayMode = $hxEnums["utest.ui.common.HeaderDisplayMode"] = { __ename__:"utest.ui.common.HeaderDisplayMode",__constructs__:null
	,AlwaysShowHeader: {_hx_name:"AlwaysShowHeader",_hx_index:0,__enum__:"utest.ui.common.HeaderDisplayMode",toString:$estr}
	,NeverShowHeader: {_hx_name:"NeverShowHeader",_hx_index:1,__enum__:"utest.ui.common.HeaderDisplayMode",toString:$estr}
	,ShowHeaderWithResults: {_hx_name:"ShowHeaderWithResults",_hx_index:2,__enum__:"utest.ui.common.HeaderDisplayMode",toString:$estr}
};
utest_ui_common_HeaderDisplayMode.__constructs__ = [utest_ui_common_HeaderDisplayMode.AlwaysShowHeader,utest_ui_common_HeaderDisplayMode.NeverShowHeader,utest_ui_common_HeaderDisplayMode.ShowHeaderWithResults];
var utest_ui_common_SuccessResultsDisplayMode = $hxEnums["utest.ui.common.SuccessResultsDisplayMode"] = { __ename__:"utest.ui.common.SuccessResultsDisplayMode",__constructs__:null
	,AlwaysShowSuccessResults: {_hx_name:"AlwaysShowSuccessResults",_hx_index:0,__enum__:"utest.ui.common.SuccessResultsDisplayMode",toString:$estr}
	,NeverShowSuccessResults: {_hx_name:"NeverShowSuccessResults",_hx_index:1,__enum__:"utest.ui.common.SuccessResultsDisplayMode",toString:$estr}
	,ShowSuccessResultsWithNoErrors: {_hx_name:"ShowSuccessResultsWithNoErrors",_hx_index:2,__enum__:"utest.ui.common.SuccessResultsDisplayMode",toString:$estr}
};
utest_ui_common_SuccessResultsDisplayMode.__constructs__ = [utest_ui_common_SuccessResultsDisplayMode.AlwaysShowSuccessResults,utest_ui_common_SuccessResultsDisplayMode.NeverShowSuccessResults,utest_ui_common_SuccessResultsDisplayMode.ShowSuccessResultsWithNoErrors];
class utest_ui_common_IReport {
}
utest_ui_common_IReport.__name__ = "utest.ui.common.IReport";
utest_ui_common_IReport.__isInterface__ = true;
Object.assign(utest_ui_common_IReport.prototype, {
	__class__: utest_ui_common_IReport
	,displaySuccessResults: null
	,displayHeader: null
});
class utest_ui_common_PackageResult {
	constructor(packageName) {
		this.isEmpty = true;
		this.packageName = packageName;
		this.classes = new haxe_ds_StringMap();
		this.packages = new haxe_ds_StringMap();
		this.stats = new utest_ui_common_ResultStats();
	}
	addResult(result,flattenPackage) {
		this.isEmpty = false;
		let pack = this.getOrCreatePackage(result.pack,flattenPackage,this);
		let cls = this.getOrCreateClass(pack,result.cls,result.setup,result.teardown);
		let fix = this.createFixture(result.method,result.assertations);
		cls.add(fix);
	}
	addClass(result) {
		this.isEmpty = false;
		this.classes.h[result.className] = result;
		this.stats.wire(result.stats);
	}
	addPackage(result) {
		this.isEmpty = false;
		this.packages.h[result.packageName] = result;
		this.stats.wire(result.stats);
	}
	existsPackage(name) {
		return Object.prototype.hasOwnProperty.call(this.packages.h,name);
	}
	existsClass(name) {
		return Object.prototype.hasOwnProperty.call(this.classes.h,name);
	}
	getPackage(name) {
		if(this.packageName == null && name == "") {
			return this;
		}
		return this.packages.h[name];
	}
	getClass(name) {
		return this.classes.h[name];
	}
	classNames(errorsHavePriority) {
		if(errorsHavePriority == null) {
			errorsHavePriority = true;
		}
		let names = [];
		let h = this.classes.h;
		let name_keys = Object.keys(h);
		let name_length = name_keys.length;
		let name_current = 0;
		while(name_current < name_length) {
			let name = name_keys[name_current++];
			names.push(name);
		}
		if(errorsHavePriority) {
			let me = this;
			names.sort(function(a,b) {
				let as = me.getClass(a).stats;
				let bs = me.getClass(b).stats;
				if(as.hasErrors) {
					if(!bs.hasErrors) {
						return -1;
					} else if(as.errors == bs.errors) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.errors,bs.errors);
					}
				} else if(bs.hasErrors) {
					return 1;
				} else if(as.hasFailures) {
					if(!bs.hasFailures) {
						return -1;
					} else if(as.failures == bs.failures) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.failures,bs.failures);
					}
				} else if(bs.hasFailures) {
					return 1;
				} else if(as.hasWarnings) {
					if(!bs.hasWarnings) {
						return -1;
					} else if(as.warnings == bs.warnings) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.warnings,bs.warnings);
					}
				} else if(bs.hasWarnings) {
					return 1;
				} else {
					return Reflect.compare(a,b);
				}
			});
		} else {
			names.sort(function(a,b) {
				return Reflect.compare(a,b);
			});
		}
		return names;
	}
	packageNames(errorsHavePriority) {
		if(errorsHavePriority == null) {
			errorsHavePriority = true;
		}
		let names = [];
		if(this.packageName == null) {
			names.push("");
		}
		let h = this.packages.h;
		let name_keys = Object.keys(h);
		let name_length = name_keys.length;
		let name_current = 0;
		while(name_current < name_length) {
			let name = name_keys[name_current++];
			names.push(name);
		}
		if(errorsHavePriority) {
			let me = this;
			names.sort(function(a,b) {
				let as = me.getPackage(a).stats;
				let bs = me.getPackage(b).stats;
				if(as.hasErrors) {
					if(!bs.hasErrors) {
						return -1;
					} else if(as.errors == bs.errors) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.errors,bs.errors);
					}
				} else if(bs.hasErrors) {
					return 1;
				} else if(as.hasFailures) {
					if(!bs.hasFailures) {
						return -1;
					} else if(as.failures == bs.failures) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.failures,bs.failures);
					}
				} else if(bs.hasFailures) {
					return 1;
				} else if(as.hasWarnings) {
					if(!bs.hasWarnings) {
						return -1;
					} else if(as.warnings == bs.warnings) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.warnings,bs.warnings);
					}
				} else if(bs.hasWarnings) {
					return 1;
				} else {
					return Reflect.compare(a,b);
				}
			});
		} else {
			names.sort(function(a,b) {
				return Reflect.compare(a,b);
			});
		}
		return names;
	}
	createFixture(method,assertations) {
		let f = new utest_ui_common_FixtureResult(method);
		let assertation = $getIterator(assertations);
		while(assertation.hasNext()) {
			let assertation1 = assertation.next();
			f.add(assertation1);
		}
		return f;
	}
	getOrCreateClass(pack,cls,setup,teardown) {
		if(pack.existsClass(cls)) {
			return pack.getClass(cls);
		}
		let c = new utest_ui_common_ClassResult(cls,setup,teardown);
		pack.addClass(c);
		return c;
	}
	getOrCreatePackage(pack,flat,ref) {
		if(pack == null || pack == "") {
			return ref;
		}
		if(flat) {
			if(ref.existsPackage(pack)) {
				return ref.getPackage(pack);
			}
			let p = new utest_ui_common_PackageResult(pack);
			ref.addPackage(p);
			return p;
		} else {
			let parts = pack.split(".");
			let _g = 0;
			while(_g < parts.length) {
				let part = parts[_g];
				++_g;
				ref = this.getOrCreatePackage(part,true,ref);
			}
			return ref;
		}
	}
}
utest_ui_common_PackageResult.__name__ = "utest.ui.common.PackageResult";
Object.assign(utest_ui_common_PackageResult.prototype, {
	__class__: utest_ui_common_PackageResult
	,packageName: null
	,isEmpty: null
	,classes: null
	,packages: null
	,stats: null
});
class utest_ui_common_ReportTools {
	static hasHeader(report,stats) {
		switch(report.displayHeader._hx_index) {
		case 0:
			return true;
		case 1:
			return false;
		case 2:
			if(!stats.isOk) {
				return true;
			}
			switch(report.displaySuccessResults._hx_index) {
			case 0:case 2:
				return true;
			case 1:
				return false;
			}
			break;
		}
	}
	static skipResult(report,stats,isOk) {
		if(!stats.isOk) {
			return false;
		}
		switch(report.displaySuccessResults._hx_index) {
		case 0:
			return false;
		case 1:
			return true;
		case 2:
			return !isOk;
		}
	}
}
utest_ui_common_ReportTools.__name__ = "utest.ui.common.ReportTools";
class utest_ui_common_ResultAggregator {
	constructor(runner,flattenPackage) {
		if(flattenPackage == null) {
			flattenPackage = false;
		}
		if(runner == null) {
			throw haxe_Exception.thrown("runner argument is null");
		}
		this.flattenPackage = flattenPackage;
		this.runner = runner;
		runner.onStart.add($bind(this,this.start));
		runner.onProgress.add($bind(this,this.progress));
		runner.onComplete.add($bind(this,this.complete));
		this.onStart = new utest_Notifier();
		this.onComplete = new utest_Dispatcher();
		this.onProgress = new utest_Dispatcher();
	}
	start(runner) {
		this.checkNonITest();
		this.root = new utest_ui_common_PackageResult(null);
		this.onStart.dispatch();
	}
	checkNonITest() {
		let first = null;
		let total = 0;
		let _g = 0;
		let _g1 = this.runner.length;
		while(_g < _g1) {
			let i = _g++;
			let fixture = this.runner.getFixture(i);
			if(!fixture.isITest) {
				++total;
				if(first == null) {
					let c = js_Boot.getClass(fixture.target);
					first = c.__name__;
				}
			}
		}
		if(total > 0) {
			let baseMsg = "implement utest.ITest. Non-ITest tests are deprecated. Implement utest.ITest or extend utest.Test.";
			let msg;
			switch(total) {
			case 1:
				msg = "" + first + " doesn't " + baseMsg;
				break;
			case 2:
				msg = "" + first + " and 1 other don't " + baseMsg;
				break;
			default:
				msg = "" + first + " and " + total + " others don't " + baseMsg;
			}
			haxe_Log.trace(msg,{ fileName : "utest/ui/common/ResultAggregator.hx", lineNumber : 54, className : "utest.ui.common.ResultAggregator", methodName : "checkNonITest"});
		}
	}
	progress(e) {
		this.root.addResult(e.result,this.flattenPackage);
		this.onProgress.dispatch(e);
	}
	complete(runner) {
		if(this.root.isEmpty) {
			this.root.addResult(this.createNoTestsResult(),false);
		}
		this.onComplete.dispatch(this.root);
	}
	createNoTestsResult() {
		let result = new utest_TestResult();
		result.pack = "";
		result.cls = "";
		result.method = "";
		result.assertations = new haxe_ds_List();
		let pos = { fileName : "", lineNumber : 1, className : "utest.Runner", methodName : "run"};
		result.assertations.add(utest_Assertation.Failure("No tests executed.",pos));
		return result;
	}
}
utest_ui_common_ResultAggregator.__name__ = "utest.ui.common.ResultAggregator";
Object.assign(utest_ui_common_ResultAggregator.prototype, {
	__class__: utest_ui_common_ResultAggregator
	,runner: null
	,flattenPackage: null
	,root: null
	,onStart: null
	,onComplete: null
	,onProgress: null
});
class utest_ui_common_ResultStats {
	constructor() {
		this.assertations = 0;
		this.successes = 0;
		this.failures = 0;
		this.errors = 0;
		this.warnings = 0;
		this.ignores = 0;
		this.isOk = true;
		this.hasFailures = false;
		this.hasErrors = false;
		this.hasWarnings = false;
		this.hasIgnores = false;
		this.onAddSuccesses = new utest_Dispatcher();
		this.onAddFailures = new utest_Dispatcher();
		this.onAddErrors = new utest_Dispatcher();
		this.onAddWarnings = new utest_Dispatcher();
		this.onAddIgnores = new utest_Dispatcher();
	}
	addSuccesses(v) {
		if(v == 0) {
			return;
		}
		this.assertations += v;
		this.successes += v;
		this.onAddSuccesses.dispatch(v);
	}
	addFailures(v) {
		if(v == 0) {
			return;
		}
		this.assertations += v;
		this.failures += v;
		this.hasFailures = this.failures > 0;
		this.isOk = !(this.hasFailures || this.hasErrors || this.hasWarnings);
		this.onAddFailures.dispatch(v);
	}
	addErrors(v) {
		if(v == 0) {
			return;
		}
		this.assertations += v;
		this.errors += v;
		this.hasErrors = this.errors > 0;
		this.isOk = !(this.hasFailures || this.hasErrors || this.hasWarnings);
		this.onAddErrors.dispatch(v);
	}
	addIgnores(v) {
		if(v == 0) {
			return;
		}
		this.assertations += v;
		this.ignores += v;
		this.hasIgnores = this.ignores > 0;
		this.onAddIgnores.dispatch(v);
	}
	addWarnings(v) {
		if(v == 0) {
			return;
		}
		this.assertations += v;
		this.warnings += v;
		this.hasWarnings = this.warnings > 0;
		this.isOk = !(this.hasFailures || this.hasErrors || this.hasWarnings);
		this.onAddWarnings.dispatch(v);
	}
	sum(other) {
		this.addSuccesses(other.successes);
		this.addFailures(other.failures);
		this.addErrors(other.errors);
		this.addWarnings(other.warnings);
		this.addIgnores(other.ignores);
	}
	wire(dependant) {
		dependant.onAddSuccesses.add($bind(this,this.addSuccesses));
		dependant.onAddFailures.add($bind(this,this.addFailures));
		dependant.onAddErrors.add($bind(this,this.addErrors));
		dependant.onAddWarnings.add($bind(this,this.addWarnings));
		dependant.onAddIgnores.add($bind(this,this.addIgnores));
		this.sum(dependant);
	}
}
utest_ui_common_ResultStats.__name__ = "utest.ui.common.ResultStats";
Object.assign(utest_ui_common_ResultStats.prototype, {
	__class__: utest_ui_common_ResultStats
	,assertations: null
	,successes: null
	,failures: null
	,errors: null
	,warnings: null
	,ignores: null
	,onAddSuccesses: null
	,onAddFailures: null
	,onAddErrors: null
	,onAddWarnings: null
	,onAddIgnores: null
	,isOk: null
	,hasFailures: null
	,hasErrors: null
	,hasWarnings: null
	,hasIgnores: null
});
class utest_ui_text_PlainTextReport {
	constructor(runner,outputHandler) {
		if(utest_ui_text_PlainTextReport._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(runner,outputHandler);
	}
	_hx_constructor(runner,outputHandler) {
		this.aggregator = new utest_ui_common_ResultAggregator(runner,true);
		runner.onStart.add($bind(this,this.start));
		this.aggregator.onComplete.add($bind(this,this.complete));
		if(null != outputHandler) {
			this.setHandler(outputHandler);
		}
		this.displaySuccessResults = utest_ui_common_SuccessResultsDisplayMode.AlwaysShowSuccessResults;
		this.displayHeader = utest_ui_common_HeaderDisplayMode.AlwaysShowHeader;
	}
	setHandler(handler) {
		this.handler = handler;
	}
	start(e) {
		this.startTime = this.getTime();
	}
	getTime() {
		let hrtime = process.hrtime();
		return hrtime[0] + hrtime[1] / 1e9;
	}
	indents(c) {
		let s = "";
		while(--c >= 0) s += this.indent;
		return s;
	}
	dumpStack(stack) {
		if(stack.length == 0) {
			return "";
		}
		let parts = haxe_CallStack.toString(stack).split("\n");
		let r = [];
		let _g = 0;
		while(_g < parts.length) {
			let part = parts[_g];
			++_g;
			if(part.indexOf(" utest.") >= 0) {
				continue;
			}
			r.push(part);
		}
		return r.join(this.newline);
	}
	addHeader(buf,result) {
		if(!utest_ui_common_ReportTools.hasHeader(this,result.stats)) {
			return;
		}
		let end = this.getTime();
		let time = ((end - this.startTime) * 1000 | 0) / 1000;
		buf.b += Std.string("\nassertations: " + result.stats.assertations + this.newline);
		buf.b += Std.string("successes: " + result.stats.successes + this.newline);
		buf.b += Std.string("errors: " + result.stats.errors + this.newline);
		buf.b += Std.string("failures: " + result.stats.failures + this.newline);
		buf.b += Std.string("warnings: " + result.stats.warnings + this.newline);
		buf.b += Std.string("execution time: " + time + this.newline);
		buf.b += Std.string(this.newline);
		buf.b += Std.string("results: " + (result.stats.isOk ? "ALL TESTS OK (success: true)" : "SOME TESTS FAILURES (success: false)"));
		buf.b += Std.string(this.newline);
	}
	getResults() {
		let buf = new StringBuf();
		this.addHeader(buf,this.result);
		let _g = 0;
		let _g1 = this.result.packageNames();
		while(_g < _g1.length) {
			let pname = _g1[_g];
			++_g;
			let pack = this.result.getPackage(pname);
			if(utest_ui_common_ReportTools.skipResult(this,pack.stats,this.result.stats.isOk)) {
				continue;
			}
			let _g2 = 0;
			let _g3 = pack.classNames();
			while(_g2 < _g3.length) {
				let cname = _g3[_g2];
				++_g2;
				let cls = pack.getClass(cname);
				if(utest_ui_common_ReportTools.skipResult(this,cls.stats,this.result.stats.isOk)) {
					continue;
				}
				buf.b += Std.string((pname == "" ? "" : pname + ".") + cname + this.newline);
				let _g = 0;
				let _g1 = cls.methodNames();
				while(_g < _g1.length) {
					let mname = _g1[_g];
					++_g;
					let fix = cls.get(mname);
					if(utest_ui_common_ReportTools.skipResult(this,fix.stats,this.result.stats.isOk)) {
						continue;
					}
					let x = this.indents(1) + mname + ": ";
					buf.b += Std.string(x);
					if(fix.stats.isOk) {
						buf.b += "OK ";
					} else if(fix.stats.hasErrors) {
						buf.b += "ERROR ";
					} else if(fix.stats.hasFailures) {
						buf.b += "FAILURE ";
					} else if(fix.stats.hasWarnings) {
						buf.b += "WARNING ";
					}
					let messages = "";
					let _g2 = fix.iterator();
					while(_g2.head != null) {
						let val = _g2.head.item;
						_g2.head = _g2.head.next;
						switch(val._hx_index) {
						case 0:
							buf.b += ".";
							break;
						case 1:
							buf.b += "F";
							messages += this.indents(2) + "line: " + val.pos.lineNumber + ", " + val.msg + this.newline;
							break;
						case 2:
							buf.b += "E";
							messages += this.indents(2) + Std.string(val.e) + this.dumpStack(val.stack) + this.newline;
							break;
						case 3:
							buf.b += "S";
							messages += this.indents(2) + Std.string(val.e) + this.dumpStack(val.stack) + this.newline;
							break;
						case 4:
							buf.b += "T";
							messages += this.indents(2) + Std.string(val.e) + this.dumpStack(val.stack) + this.newline;
							break;
						case 5:
							buf.b += "O";
							messages += this.indents(2) + "missed async calls: " + val.missedAsyncs + this.dumpStack(val.stack) + this.newline;
							break;
						case 6:
							buf.b += "A";
							messages += this.indents(2) + Std.string(val.e) + this.dumpStack(val.stack) + this.newline;
							break;
						case 7:
							buf.b += "W";
							messages += this.indents(2) + val.msg + this.newline;
							break;
						case 8:
							let _g = val.reason;
							buf.b += "I";
							if(_g != null && _g != "") {
								messages += this.indents(2) + ("With reason: " + _g) + this.newline;
							}
							break;
						}
					}
					buf.b = (buf.b += Std.string(this.newline)) + (messages == null ? "null" : "" + messages);
				}
			}
		}
		return buf.b;
	}
	complete(result) {
		this.result = result;
		if(this.handler != null) {
			this.handler(this);
		}
		if(typeof phantom != "undefined") {
			let tmp = result.stats.isOk ? 0 : 1;
			phantom.exit(tmp);
		}
		if(typeof process != "undefined") {
			let tmp = result.stats.isOk ? 0 : 1;
			process.exit(tmp);
		}
	}
}
utest_ui_text_PlainTextReport.__name__ = "utest.ui.text.PlainTextReport";
utest_ui_text_PlainTextReport.__interfaces__ = [utest_ui_common_IReport];
Object.assign(utest_ui_text_PlainTextReport.prototype, {
	__class__: utest_ui_text_PlainTextReport
	,displaySuccessResults: null
	,displayHeader: null
	,handler: null
	,aggregator: null
	,newline: null
	,indent: null
	,startTime: null
	,result: null
});
class utest_ui_text_PrintReport extends utest_ui_text_PlainTextReport {
	constructor(runner) {
		utest_ui_text_PlainTextReport._hx_skip_constructor = true;
		super();
		utest_ui_text_PlainTextReport._hx_skip_constructor = false;
		this._hx_constructor(runner);
	}
	_hx_constructor(runner) {
		super._hx_constructor(runner,$bind(this,this._handler));
		this.newline = "\n";
		this.indent = "  ";
	}
	_handler(report) {
		this._trace(report.getResults());
	}
	_trace(s) {
		s = StringTools.replace(s,"  ",this.indent);
		s = StringTools.replace(s,"\n",this.newline);
		haxe_Log.trace(s,{ fileName : "utest/ui/text/PrintReport.hx", lineNumber : 52, className : "utest.ui.text.PrintReport", methodName : "_trace"});
	}
}
utest_ui_text_PrintReport.__name__ = "utest.ui.text.PrintReport";
utest_ui_text_PrintReport.__super__ = utest_ui_text_PlainTextReport;
Object.assign(utest_ui_text_PrintReport.prototype, {
	__class__: utest_ui_text_PrintReport
});
class utest_utils_AccessoriesUtils {
	static getSetupClass(accessories) {
		if(accessories.setupClass == null) {
			return utest_Async.getResolved;
		} else {
			return accessories.setupClass;
		}
	}
	static getSetup(accessories) {
		if(accessories.setup == null) {
			return utest_Async.getResolved;
		} else {
			return accessories.setup;
		}
	}
	static getTeardown(accessories) {
		if(accessories.teardown == null) {
			return utest_Async.getResolved;
		} else {
			return accessories.teardown;
		}
	}
	static getTeardownClass(accessories) {
		if(accessories.teardownClass == null) {
			return utest_Async.getResolved;
		} else {
			return accessories.teardownClass;
		}
	}
}
utest_utils_AccessoriesUtils.__name__ = "utest.utils.AccessoriesUtils";
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	String.prototype.__class__ = String;
	String.__name__ = "String";
	Array.__name__ = "Array";
	Date.prototype.__class__ = Date;
	Date.__name__ = "Date";
	var Int = { };
	var Dynamic = { };
	var Float = Number;
	var Bool = Boolean;
	var Class = { };
	var Enum = { };
}
js_Boot.__toStr = ({ }).toString;
gmdebug_Cross.FOLDER = "gmdebug";
gmdebug_Cross.INPUT = haxe_io_Path.join([gmdebug_Cross.FOLDER,"in.dat"]);
gmdebug_Cross.OUTPUT = haxe_io_Path.join([gmdebug_Cross.FOLDER,"out.dat"]);
gmdebug_Cross.READY = haxe_io_Path.join([gmdebug_Cross.FOLDER,"ready.dat"]);
gmdebug_Cross.DATA = "data";
gmdebug_composer_ComposedProtocolMessage._hx_skip_constructor = false;
gmdebug_dap_ClientStorage.SERVER_ID = 0;
tink_core_Callback.depth = 0;
tink_core_SimpleDisposable._hx_skip_constructor = false;
tink_core__$Future_NeverFuture.inst = new tink_core__$Future_NeverFuture();
tink_core_Future.NEVER = tink_core__$Future_NeverFuture.inst;
utest_ui_text_PlainTextReport._hx_skip_constructor = false;
test_Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=test.js.map